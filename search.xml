<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Controller规范]]></title>
    <url>%2F2019%2F08%2F27%2FController%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[概述 所有函数返回统一的ResultBean格式 ResultBean是controller专用的，不允许往后传 Controller做参数格式的转换，不允许把json，map这类对象传到services去，也不允许services返回json、map 参数中一般情况不允许出现Request，Response这些对象 不需要打印日志 ResultBean定义带泛型，使用了lombok12345678910111213141516171819202122232425262728293031323334@Datapublic class ResultBean&lt;T&gt; implements Serializable &#123; private static final long serialVersionUID = 1L; public static final int NO_LOGIN = -1; public static final int SUCCESS = 0; public static final int FAIL = 1; public static final int NO_PERMISSION = 2; private String msg = "success"; private int code = SUCCESS; private T data; public ResultBean() &#123; super(); &#125; public ResultBean(T data) &#123; super(); this.data = data; &#125; public ResultBean(Throwable e) &#123; super(); this.msg = e.toString(); this.code = FAIL; &#125;&#125;]]></content>
      <categories>
        <category>1-基础</category>
      </categories>
      <tags>
        <tag>规范</tag>
        <tag>Controller</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java日志框架]]></title>
    <url>%2F2019%2F08%2F15%2Fjava%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[概述日志体系如下： 日志级别 级别 描述 FATAL 导致应用程序终止的严重问题 ERROR 运行时错误 WARNING 在大多数情况下，这种级别的错误是由于使用了已弃用的API INFO 运行时发生的事件 DEBUG 有关系统流程的信息 TRACE 有关系统流程的更多详细信息 使用12static final Logger logger = LoggerFactory.getLogger("SampleLogger");logger.info("Hi This is my first SLF4J program.");]]></content>
      <categories>
        <category>1-基础</category>
      </categories>
      <tags>
        <tag>logger</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常总结]]></title>
    <url>%2F2019%2F08%2F08%2F%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一个.java源文件中是否可以包含多个类？一个.java源文件可以包含多个类，但public修饰的类最多只能有一个如果有public修饰的类，则文件名必须是public类的类名如果没有public修饰的类，则文件名可以是随便一个类的类名 String为什么是final的？为了实现字符串池为了提高效率为了线程安全为了实现hashcode不变性 为什么重写equals必须重写hashcode为了满足equals与hashcode之间的规定： 如果两个对象相同（即用equals比较返回true），那么它们的hashCode值一定要相同 如果两个对象的hashCode相同，它们并不一定相同 什么是finalizefinalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法 Exception和Error有什么区别Error是java程序无法处理的错误Exception是java程序可以处理的异常 锁机制有什么作用有些业务逻辑在执行过程中要求对数据进行排他性的访问，于是需要通过一些机制保证在此过程中数据被锁住不会被外界修改，这就是所谓的锁机制。 sql的分页查询Oracle：12345SELECT *FROM (SELECT A.*, ROWNUM RNFROM (SELECT * FROM TABLE_NAME) AWHERE ROWNUM &lt;= 40)WHERE RN &gt; 20 这里之所以需要三层嵌套，是因为： 首先，在没有order by clause的情况下，oracle的查询结果的顺序会是不确定的。 其次，在order by 和 ROWNUM同时使用时，oracle默认的策略是先为伪列rownum赋值，再order by。所以，第二层嵌套的目的就是：让结果先order by，再取rownum!。 最后，因为rownum不可使用 &gt;(=) 来判断的原因，所以需要最外围的第三层嵌套。 MySQL:1Select * from TABLE_NAME limit startrow,pagesize TCP 为什么是三次握手 为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤 如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认 python单引号和双引号的区别当你用单引号’ ‘定义字符串的时候，它就会认为你字符串里面的双引号” “是普通字符，从而不需要转义。反之当你用双引号定义字符串的时候，就会认为你字符串里面的单引号是普通字符无需转义。]]></content>
  </entry>
  <entry>
    <title><![CDATA[JdbcTemplate使用总结]]></title>
    <url>%2F2019%2F08%2F01%2FjdbcTemplate%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[JDBCJDBC：Java Data Base Connection简单来说JDBC就是为多种关系型数据库提供统一访问的一组接口。 通过JDBC操作数据库的一般步骤： 1.注册驱动Class.forName(&quot;com.mysql.jdbc.Driver&quot;); 2.建立连接Connection conn =DriverManager.getConnection(url, user, password); 3.创建运行SQL的语句12Statement st = connection.createStatement();PreparedStatement ps=connection.prepareStatement("update user set id=? where username=?"); 4.运行语句1234executeQuery(Stringsql)//该方法用于运行实现查询功能的sql语句。返回类型为ResultSet（结果集）。如：ResultSet rs =st.executeQuery(sql);executeUpdate(Stringsql)//该方法用于运行实现增、删、改功能的sql语句，返回类型为int，即受影响的行数。如：int flag = st.executeUpdate(sql); 5.处理运行结果123while (rs.next())&#123; ...&#125; 6.释放资源123conn.close();ps.close();rs.close(); JdbcTemplateJDBCTemplate就是一个模板，通过设置JDBCTemplate可以减少对数据库的繁琐操作,例如连接数据库,获得链接关闭,获得statement,resultset,preparedstatement这些等等。 JdbcTemplate主要提供下列方法： execute方法：可以用于执行任何SQL语句，一般用于执行DDL语句 update方法及batchUpdate方法：update方法用于执行新增、修改、删除等语句；batchUpdate方法用于执行批处理相关语句 query方法及queryForXXX方法：用于执行查询相关语句 call方法：用于执行存储过程、函数相关语句 query方法如下： 方法 作用 query(sql,new BeanPropertyRowMapper(实体类.class),参数 ) 查询多个对象，返回的是一个List对象，List对象存储是实体类 queryForList(sql,参数) 查询多个对象，返回一个List对象，List对象存储是Map对象 queryForObject(sql,数据类型.class) 查询单个对象 queryForObject(sql,new BeanPropertyRowMapper(实体类.class),参数) 查询单个对象,返回单个实体类对象 queryForMap(sql,参数) 查询单个对象，返回一个Map对象]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>jdbc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx的深入理解]]></title>
    <url>%2F2019%2F07%2F24%2FNginx%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[概述Nginx是一个高性能的HTTP和反向代理服务器，主要负责请求转发。具体有以下几个作用： 解决跨域 请求过滤 配置gzip 负载均衡 静态资源服务器 正向代理和反向代理两张图一目了然： Nginx的基本配置123456789101112131415161718192021events &#123; &#125;http &#123; server &#123; location path &#123; ... &#125; location path &#123; ... &#125; &#125; server &#123; ... &#125;&#125; main:nginx的全局配置，对全局生效。 events:配置影响nginx服务器或与用户的网络连接。 http：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。 server：配置虚拟主机的相关参数，一个http中可以有多个server。 location：配置请求的路由，以及各种页面的处理情况。 upstream：配置后端服务器具体地址，负载均衡配置不可或缺的部分。 解决跨域1234567server &#123; listen 80; server_name fe.server.com; location / &#123; proxy_pass dev.server.com; &#125;&#125; 负载均衡upstream指定后端服务器地址列表12345upstream balanceServer &#123; server 10.1.22.33:12345; server 10.1.22.34:12345; server 10.1.22.35:12345;&#125; 在server中拦截响应请求，并将请求转发到Upstream中配置的服务器列表1234567server &#123; server_name fe.server.com; listen 80; location /api &#123; proxy_pass http://balanceServer; &#125;&#125; nginx实现负载均衡的策略: 轮询策略：默认情况下采用的策略，将所有客户端请求轮询分配给服务端 最小连接数策略：将请求优先分配给压力较小的服务器，它可以平衡每个队列的长度，并避免向压力大的服务器添加更多的请求 最快响应时间策略：依赖于NGINX Plus，优先分配给响应时间最短的服务器 客户端ip绑定：来自同一个ip的请求永远只分配一台服务器，有效解决了动态网页存在的session共享问题]]></content>
      <categories>
        <category>9-网站架构</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8新特性总结]]></title>
    <url>%2F2019%2F07%2F23%2FJava8%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Lambda表达式函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。可以使用@FunctionalInterface注解，声明一个接口是函数式接口。如果一个接口满足函数式接口的定义，会默认转换成函数式接口。函数式接口可以被隐式转换为 lambda 表达式，即Lambda表达式可以用来代替一个匿名类。Lambda表达式即匿名函数，是一段没有函数名的函数体，可以作为参数直接传递给相关的调用者。语法结构：(parameters) -&gt;{ statements; } 可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。 可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。 可选的大括号：如果主体包含了一个语句，就不需要使用大括号。 可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。 方法引用方法引用是为了进一步简化lambda表达式。使用lambda表达式：Arrays.sort(arr, (a ,b) -&gt; Person.compareByAge(a, b));使用方法引用：Arrays.sort(arr, Person::compareByAge)方法引用一共有以下几种形式： 静态方法引用：ClassName::methodName 实例上的实例方法引用：instanceName::methodName 超类上的实例方法引用：supper::methodName 类的实例方法引用：ClassName:methodName 构造方法引用：Class:new 数组构造方法引用：TypeName[]::new StreamStream是一种新的数据处理方式，结合lambda表达式能够更加简洁高效的处理数据。Stream使用类似Iterator的方式可以将数据进行如筛选、排序以及聚合等多种操作。一般流程：获取数据源–&gt;转换成Stream–&gt;执行操作，返回一个新的Stream–&gt;再以新的Stream继续执行操作–&gt;直至最后操作输出最终结果生成Stream的方式：123456789101112Collection.stream();Collection.parallelStream();Arrays.stream(T array);Stream.of()；generate(Supplier s);iterate(T seed, UnaryOperator f);empty();Random.ints()BitSet.stream()Pattern.splitAsStream(java.lang.CharSequence)JarFile.stream()BufferedReader.lines() 例子：stream.map(str -&gt; str + &quot;hello,&quot;).forEach(System.out::println); 接口的默认方法和静态方法在Java8中接口除了能够包含抽象方法外还能够包含若干个通过default关键字定义的默认方法和静态方法。 Optional解决了空指针异常详情点这里 Date-time API的改进Java 8通过发布新的Date-Time API (JSR 310)来进一步加强对日期与时间的处理。]]></content>
      <categories>
        <category>1-基础</category>
      </categories>
      <tags>
        <tag>Java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[commit和pull的先后顺序]]></title>
    <url>%2F2019%2F07%2F17%2Fcommit%E5%92%8Cpull%E7%9A%84%E5%85%88%E5%90%8E%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[两个原则： 在本地修改与远程代码无冲突的情况下，优先使用：pull-&gt;commit-&gt;push 在本地修改与远程代码有冲突的情况下，优先使用：commit-&gt;pull-&gt;push 如果在有冲突的情况下，先pull了，那么会导致pull失败，并不会覆盖未提交的代码。以上。]]></content>
      <categories>
        <category>7-工具</category>
      </categories>
      <tags>
        <tag>commit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域总结]]></title>
    <url>%2F2019%2F07%2F17%2F%E8%B7%A8%E5%9F%9F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[概述当一个请求url的协议、域名、端口三者之间任意一个与当前页面url不同即为跨域 跨域的原因跨域的原因是由于浏览器的同源策略的限制。同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）。同源策略将会导致： 无法向非同源地址发送 AJAX 请求 无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB 无法接触非同源网页的 DOM 跨域的解决方法1.JSONP核心思想：网页通过添加一个&lt;script&gt;标签，向服务器请求 JSON 数据，服务器收到请求后，将数据放在一个指定名字的回调函数的参数位置传回来。 jQuery实现jsonp:123456789$.ajax(&#123; url:"http://crossdomain.com/services.php", dataType:'jsonp', data:'', jsonp:'callback', success:function(result) &#123; // some code &#125; &#125;); JSONP的不足之处： 只能使用get方法，不能使用post方法 没有关于 JSONP 调用的错误处理 2.CORSCORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。它为Web服务器定义了一种方式，允许网页从不同的域访问其资源.CORS系统定义了一种浏览器和服务器交互的方式来确定是否允许跨域请求。 它是一个妥协，有更大的灵活性，但比起简单地允许所有这些的要求来说更加安全。 实现方法： CORS需要浏览器和服务器同时支持 浏览器端自动完成 服务器端设置Access-Control-Allow-Origin]]></content>
      <categories>
        <category>9-网站架构</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis返回One和List的区别]]></title>
    <url>%2F2019%2F07%2F17%2FMybatis%E8%BF%94%E5%9B%9EOne%E5%92%8CList%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[返回One当返回One也就是返回一个对象时： 若数据库查询结果超过一条记录，Mybatis 则抛出非检查类异常，证明查询结果超出一条 若查询结果没有记录，则返回null 返回List 若查询结果没有记录，则返回一个空的list，不会出现 null 的情况 可以使用list.isEmpty()判空]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[resultType和resultMap的区别]]></title>
    <url>%2F2019%2F07%2F16%2FresultType%E5%92%8CresultMap%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[resultMap resultMap是在 mapper.xml 文件中通过 resultMap 节点定义出来的 resultMap将sql查询结果映射为resultMap节点定义的对象 如果sql查询列名和最终要映射的pojo的属性名不一致，使用resultMap将列名和pojo的属性名做一个对应关系 resultType resultType是自定义的类或者 jdk 自带的类、基本数据类型（int、double、String） resultType将sql查询结果映射为指定类型（pojo、java基本数据类型、hashmap） sql查询的列名要和resultType指定pojo的属性名相同 Mybatis默认定义的别名mybatis 默认在 org.apache.ibatis.type.TypeAliasRegistry 中为我们定义了类的别名：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950registerAlias("string", String.class);registerAlias("byte", Byte.class);registerAlias("long", Long.class);registerAlias("short", Short.class);registerAlias("int", Integer.class);registerAlias("integer", Integer.class);registerAlias("double", Double.class);registerAlias("float", Float.class);registerAlias("boolean", Boolean.class);registerAlias("byte[]", Byte[].class);registerAlias("long[]", Long[].class);registerAlias("short[]", Short[].class);registerAlias("int[]", Integer[].class);registerAlias("integer[]", Integer[].class);registerAlias("double[]", Double[].class);registerAlias("float[]", Float[].class);registerAlias("boolean[]", Boolean[].class);registerAlias("_byte", byte.class);registerAlias("_long", long.class);registerAlias("_short", short.class);registerAlias("_int", int.class);registerAlias("_integer", int.class);registerAlias("_double", double.class);registerAlias("_float", float.class);registerAlias("_boolean", boolean.class);registerAlias("_byte[]", byte[].class);registerAlias("_long[]", long[].class);registerAlias("_short[]", short[].class);registerAlias("_int[]", int[].class);registerAlias("_integer[]", int[].class);registerAlias("_double[]", double[].class);registerAlias("_float[]", float[].class);registerAlias("_boolean[]", boolean[].class);registerAlias("date", Date.class);registerAlias("decimal", BigDecimal.class);registerAlias("bigdecimal", BigDecimal.class);registerAlias("biginteger", BigInteger.class);registerAlias("object", Object.class);registerAlias("date[]", Date[].class);registerAlias("decimal[]", BigDecimal[].class);registerAlias("bigdecimal[]", BigDecimal[].class);registerAlias("biginteger[]", BigInteger[].class);registerAlias("object[]", Object[].class);registerAlias("map", Map.class);registerAlias("hashmap", HashMap.class);registerAlias("list", List.class);registerAlias("arraylist", ArrayList.class);registerAlias("collection", Collection.class);registerAlias("iterator", Iterator.class);registerAlias("ResultSet", ResultSet.class);]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AOP实现原理之代理模式]]></title>
    <url>%2F2019%2F06%2F27%2FAOP%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[概述代理模式即通过创建一个代理对象，用这个代理对象去代表真正的对象，客户端使用这个代理对象来操作真正的对象，主要有静态代理和动态代理两种。 静态代理接口类：123interface Person &#123; void speak();&#125; 真实对象类：1234567891011class Actor implements Person &#123; private String content; public Actor(String content) &#123; this.content = content; &#125; @Override public void speak() &#123; System.out.println(this.content); &#125;&#125; 代理类：12345678910111213141516171819class Agent implements Person &#123; private Actor actor; private String before; private String after; public Agent(Actor actor, String before, String after) &#123; this.actor = actor; this.before = before; this.after = after; &#125; @Override public void speak() &#123; //before speak System.out.println("Before actor speak, Agent say: " + before); //real speak this.actor.speak(); //after speak System.out.println("After actor speak, Agent say: " + after); &#125;&#125; JDK动态代理JDK动态代理只能代理接口。使用步骤： 新建一个接口 为接口创建一个实现类 创建代理类实现java.lang.reflect.InvocationHandler接口 测试 接口类：1234public interface Subject &#123; void doSomething();&#125; 真实对象类：123456public class RealSubject implements Subject &#123; @Override public void doSomething() &#123; System.out.println("RealSubject do something"); &#125;&#125; 代理类,实现java.lang.reflect.InvocationHandler接口，重写invoke方法：12345678910111213141516171819202122232425public class JDKDynamicProxy implements InvocationHandler &#123; private Object target; public JDKDynamicProxy(Object target) &#123; this.target = target; &#125; /** * 获取被代理接口实例对象 * @param &lt;T&gt; * @return */ public &lt;T&gt; T getProxy() &#123; return (T) Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this); &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("Do something before"); Object result = method.invoke(target, args); System.out.println("Do something after"); return result; &#125;&#125; 测试类：1234567public class Client &#123; public static void main(String[] args) &#123; // jdk动态代理测试 Subject subject = new JDKDynamicProxy(new RealSubject()).getProxy(); subject.doSomething(); &#125;&#125; CGLIB代理JDK的动态代理机制只能代理实现了接口的类，而不能实现接口的类就不能实现JDK的动态代理，cglib是针对类来实现代理的，他的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理。 使用例子：1234567891011121314151617181920212223242526272829public class CGlibAgent implements MethodInterceptor &#123; private Object target; public Object getInstance(Object target) &#123; this.target = target; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(this.target.getClass()); // 回调方法 enhancer.setCallback(this); // 创建代理对象 return enhancer.create(); &#125; //回调方法 @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; System.out.println("Do something before"); //真正调用 Object ret = methodProxy.invokeSuper(o, objects); System.out.println("Do something after"); return ret; &#125; public static void main(String[] args) &#123; CGlibAgent cGlibAgent = new CGlibAgent(); Subject subject = cGlibAgent.getInstance(new Subject()); subject.doSomething(); &#125;&#125;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>AOP</tag>
        <tag>代理模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重构二叉树]]></title>
    <url>%2F2019%2F06%2F21%2F%E9%87%8D%E6%9E%84%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目概述输入某二叉树的前序遍历和中序遍历的结果，假设结果中不包含重复元素，请重建该二叉树。 算法思路 前序序列的第一个值就是根节点的值。 在中序序列中找到这个值，那么这个值左边的序列为左子树，右边的序列为右子树。 分别对左右子树进行递归调用。 算法实现12345678910111213141516171819202122232425262728293031/** * Definition for binary tree * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; return reConstruct(pre,0,pre.length-1,in,0,in.length-1); &#125; private TreeNode reConstruct(int[] pre,int startPre,int endPre,int[] in,int startIn, int endIn)&#123; if(startPre&gt;endPre)&#123; return null; &#125; TreeNode root = new TreeNode(pre[startPre]); int index = 0; for(int i=startIn;i&lt;=endIn;i++)&#123; if(pre[startPre] == in[i])&#123; index = i; break; &#125; &#125; root.left = reConstruct(pre,startPre+1,index-startIn+startPre,in,startIn,index-1); root.right = reConstruct(pre,index-startIn+startPre+1,endPre,in,index+1,endIn); return root; &#125;&#125;]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[N皇后]]></title>
    <url>%2F2019%2F06%2F17%2FN%E7%9A%87%E5%90%8E%2F</url>
    <content type="text"><![CDATA[概述n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 题目描述给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。 示例：12345678910111213输入: 4输出: [ [".Q..", // 解法 1 "...Q", "Q...", "..Q."], ["..Q.", // 解法 2 "Q...", "...Q", ".Q.."]]解释: 4 皇后问题存在两个不同的解法。 算法思路采用回溯算法，深度优先遍历所有可能，输出满足要求的可能。表示方式： arr[i] = k; 表示： 第i行的第k个位置放一个皇后。算法步骤： 从第一行第一个位置开始遍历，先判断是否满足要求，若满足，则放置一个皇后； 然后递归调用下一行； 若所有行都被考虑过，则得出一种解法； 算法实现1234567891011121314151617181920212223242526272829303132333435363738394041424344public class SolveNQueens &#123; int n; int[] arr; List&lt;List&lt;String&gt;&gt; output = new ArrayList&lt;&gt;(); public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; this.n = n; arr = new int[n]; backTrack(0); return output; &#125; public boolean check(int row, int col)&#123; for(int i =0; i&lt;row; i++)&#123; if(col == arr[i] || Math.abs(row-i) == Math.abs(col-arr[i])) return false; &#125; return true; &#125; public void backTrack(int k)&#123; if(k == n)&#123; addSolution(); &#125; for(int i=0;i&lt;n;i++)&#123; if(check(k,i))&#123; arr[k] = i; backTrack(k + 1); &#125; &#125; &#125; public void addSolution()&#123; List&lt;String&gt; solution = new ArrayList&lt;&gt;(); for(int i = 0; i&lt;n;i++)&#123; StringBuilder sb = new StringBuilder(); for(int j = 0;j&lt;arr[i];j++) sb.append("."); sb.append("Q"); for(int j = arr[i]+1;j&lt;n;j++) sb.append("."); solution.add(sb.toString()); &#125; output.add(solution); &#125;&#125;]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>N皇后</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[消息队列总结]]></title>
    <url>%2F2019%2F05%2F30%2F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[概述消息队列中间件是分布式系统中一个重要的组件，主要解决系统解耦，异步处理，流量削峰等问题，实现高性能，高可用可伸缩和最终一致性架构。目前使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ。 应用场景1.通过异步处理进行流量削峰 在不使用消息队列服务器的时候，用户的请求直接写入数据库，在高并发的情况下数据库的压力剧增，使得响应速度变慢。使用消息队列后，用户的请求数据发送给消息队列后立即返回，再由消息队列的消费者进程从消息队列中获取数据，异步写入数据库。由于消息队列的处理速度快于数据库，且消息队列也比数据库有更好的伸缩性，因此响应速度大大加快，同时也起到了流量削峰的作用。 2.系统解耦如果模块之间不存在直接调用，那么新增模块就对其他模块影响较小，系统耦合性也就更低。消息队列利用发布-订阅模式，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息。消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计。 JMSJMS（JAVA Message Service,java消息服务）是基于JVM消息代理的规范，JMS的客户端之间可以通过JMS服务进行异步的消息传输。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。1.点对点模型使用队列（Queue）作为消息通信载体；满足生产者与消费者模式，一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时。 2.发布订阅模型发布订阅模型（Pub/Sub） 使用主题（Topic）作为消息通信载体，类似于广播模式；发布者发布一条消息，该消息通过主题传递给所有的订阅者，在一条消息广播之后才订阅的用户则是收不到该条消息的。 3.JMS 五种不同的消息正文格式 StreamMessage – Java原始值的数据流 MapMessage–一套名称-值对 TextMessage–一个字符串对象 ObjectMessage–一个序列化的 Java对象 BytesMessage–一个字节的数据流 AMQPAMQP(Advanced Message Queuing Protocol)，即高级消息队列协议，也是一个消息代理的规范，兼容JMS。 5种消息模型 direct exchange fanout exchange topic change headers exchange system exchange本质来讲，后四种和JMS的发布订阅模型没有太大的差别，只不过在路由机制上做了更详细的划分。 JMS和AMQP对比 AMQP 为消息定义了线路层（wire-level protocol）的协议，而JMS所定义的是API规范。在 Java 体系中，多个client均可以通过JMS进行交互，不需要应用修改代码，但是其对跨平台的支持较差。而AMQP天然具有跨平台、跨语言特性。 JMS 支持TextMessage、MapMessage 等复杂的消息类型；而 AMQP 仅支持 byte[] 消息类型（复杂的类型可序列化后发送）。 由于Exchange 提供的路由算法，AMQP可以提供多样化的路由方式来传递消息到消息队列，而 JMS 仅支持 队列 和 主题/订阅 方式两种。]]></content>
      <categories>
        <category>8-分布式</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之工厂模式]]></title>
    <url>%2F2019%2F05%2F22%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[工厂模式的分类 简单工厂（Simple Factory）模式，又称静态工厂方法模式（Static Factory Method Pattern）。 工厂方法（Factory Method）模式，又称多态性工厂（Polymorphic Factory）模式或虚拟构造子（Virtual Constructor）模式； 抽象工厂（Abstract Factory）模式，又称工具箱（Kit 或Toolkit）模式。 作用 解耦：把对象的创建和使用的过程分开 降低维护成本 简单工厂模式简单工厂模式属于创建型模式，又叫静态工厂方法模式，但不属于23种GOF设计模式。简单工厂模式是根据传入的参数不同返回不同的实例，被创建的实例具有共同的父类或接口。 角色分配： 工厂(Factory)角色 :简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类可以被外界直接调用，创建所需的产品对象。 抽象产品(Product)角色 :简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。 具体产品(Concrete Product)角色:简单工厂模式的创建目标，所有创建的对象都是充当这个角色的某个具体类的实例。 使用例子：1.创建Shape接口123public interface Shape &#123; void draw();&#125; 2.创建实现类123456789public class Circle implements Shape &#123; public Circle() &#123; System.out.println("Circle"); &#125; @Override public void draw() &#123; System.out.println("Draw Circle"); &#125;&#125; 3.创建工厂类1234567891011121314151617public class ShapeFactory &#123; // 使用 getShape 方法获取形状类型的对象 public static Shape getShape(String shapeType) &#123; if (shapeType == null) &#123; return null; &#125; if (shapeType.equalsIgnoreCase("CIRCLE")) &#123; return new Circle(); &#125; else if (shapeType.equalsIgnoreCase("RECTANGLE")) &#123; return new Rectangle(); &#125; else if (shapeType.equalsIgnoreCase("SQUARE")) &#123; return new Square(); &#125; return null; &#125;&#125; 工厂方法模式在工厂方法模式中，针对不同的对象提供不同的工厂。 角色分配： 抽象工厂(Abstract Factory)角色：是工厂方法模式的核心，与应用程序无关。任何在模式中创建的对象的工厂类必须实现这个接口。 具体工厂(Concrete Factory)角色 ：这是实现抽象工厂接口的具体工厂类，包含与应用程序密切相关的逻辑，并且受到应用程序调用以创建某一种产品对象。 抽象产品(AbstractProduct)角色 ：工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口。 具体产品(Concrete Product)角色 ：这个角色实现了抽象产品角色所定义的接口。某具体产品有专门的具体工厂创建，它们之间往往一一对应。 使用例子：1.图形接口和实现类不变2.增加一个工厂接口123public interface Factory &#123; public Shape getShape();&#125; 3.增加工厂实现类12345678public class CircleFactory implements Factory &#123; @Override public Shape getShape() &#123; // TODO Auto-generated method stub return new Circle(); &#125;&#125; 4.测试12345678public class Test &#123; public static void main(String[] args) &#123; Factory circlefactory = new CircleFactory(); Shape circle = circlefactory.getShape(); circle.draw(); &#125;&#125; 抽象工厂模式抽象工厂模式不单单可以创建一个对象，而是可以创建一组对象。 使用例子：1.创建抽象产品类123456789//抽象操作控制器public interface OperationController &#123; void control();&#125;//抽象界面控制器public interface UIController &#123; void display();&#125; 2.创建产品实现类12345678910111213141516//Android下的实现public class AndroidOperationController implements OperationController &#123; @Override public void control() &#123; System.out.println("AndroidOperationController"); &#125;&#125;public class AndroidUIController implements UIController &#123; @Override public void display() &#123; System.out.println("AndroidInterfaceController"); &#125;&#125;//Ios下的实现pass 3.创建抽象工厂类1234public interface SystemFactory &#123; public OperationController createOperationController(); public UIController createInterfaceController();&#125; 4.创建工厂实现类1234567891011121314//Android下的工厂实现类public class AndroidFactory implements SystemFactory &#123; @Override public OperationController createOperationController() &#123; return new AndroidOperationController(); &#125; @Override public UIController createInterfaceController() &#123; return new AndroidUIController(); &#125;&#125;//IOS下的工厂实现类pass 5.测试12345678910111213141516public class Test &#123; public static void main(String[] args) &#123; SystemFactory mFactory; UIController interfaceController; OperationController operationController; //Android mFactory=new AndroidFactory(); //Ios mFactory=new IosFactory(); interfaceController=mFactory.createInterfaceController(); operationController=mFactory.createOperationController(); interfaceController.display(); operationController.control(); &#125;&#125;]]></content>
      <categories>
        <category>6-设计模式</category>
      </categories>
      <tags>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式系统的基础理论]]></title>
    <url>%2F2019%2F05%2F08%2F%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[概述分布式系统的目标是提升系统的整体性能和吞吐量以及保证分布式系统的容错性。 分布式系统设计思路1.中心化 两个角色：领导和员工 领导负责分发任务并监督员工 领导如果发现某个员工病倒了，会直接将其踢出去，把任务分给其他人。 2.去中心化 角色平等 例如ZooKeeper 分布式与集群 分布式：一个业务拆分成多个子业务，部署在不同的服务器上 集群：同一个业务，部署在多个服务器上 CAP定理一个分布式系统不可能同时满足以下三点： 一致性（Consistence） :所有节点访问同一份最新的数据副本 可用性（Availability）:每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据 分区容错性（Partition tolerance） : 分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务 在分布式系统中，分区容忍性必不可少，因为需要总是假设网络是不可靠的。因此，CAP 理论实际上是要在可用性和一致性之间做权衡。 可用性和一致性往往是冲突的，很难使它们同时满足。在多个节点之间进行数据同步时， 为了保证一致性（CP），不能访问未同步完成的节点，也就失去了部分可用性 为了保证可用性（AP），允许读取所有节点的数据，但是数据可能不一致 BASE理论BASE 是基本可用（Basically Available）、软状态（Soft State）和最终一致性（Eventually Consistent）三个短语的缩写。 BASE 理论是对 CAP 中一致性和可用性权衡的结果，它的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。 1.基本可用基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。但是，这绝不等价于系统不可用。 比如： 响应时间上的损失:正常情况下，一个在线搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障，查询结果的响应时间增加了1~2秒 系统功能上的损失：正常情况下，在一个电子商务网站上进行购物的时候，消费者几乎能够顺利完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面 2.软状态软状态指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。 3.最终一致性最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。]]></content>
      <categories>
        <category>8-分布式</category>
      </categories>
      <tags>
        <tag>理论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo总结]]></title>
    <url>%2F2019%2F05%2F06%2Fdubbo%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[概述Dubbo是一款高性能、轻量级的开源Java RPC 框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。简单来说 Dubbo 是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。 Dubbo的架构 服务提供者（Provider）：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者（Consumer）: 调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 注册中心（Registry）：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 监控中心（Monitor）：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 容器（Container）： 运行服务的容器。 调用关系： 服务容器负责启动，加载，运行服务提供者。 服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者在启动时，向注册中心订阅自己所需的服务。 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 Dubbo的作用 透明化的远程方法调用，就像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入。 软负载均衡及容错机制，可在内网替代F5等硬件负载均衡器，降低成本，减少单点。 服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。]]></content>
      <categories>
        <category>9-网站架构</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解RPC]]></title>
    <url>%2F2019%2F05%2F06%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3RPC%2F</url>
    <content type="text"><![CDATA[概述RPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，它是一种技术的思想，而不是规范，它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显示编码这个远程调用的细节，即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。 RPC基本原理 1.服务消费方（client）调用以本地调用方式调用服务；2.client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；3.client stub找到服务地址，并将消息发送到服务端；4.server stub收到消息后进行解码；5.server stub根据解码结果调用本地的服务；6.本地服务执行并将结果返回给server stub；7.server stub将返回结果打包成消息并发送至消费方；8.client stub接收到消息，并进行解码；9.服务消费方得到最终结果。 RPC的目标就是要2~8这些步骤都封装起来，让用户对这些细节透明。]]></content>
      <categories>
        <category>9-网站架构</category>
      </categories>
      <tags>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SOA架构和微服务架构]]></title>
    <url>%2F2019%2F05%2F05%2FSOA%E6%9E%B6%E6%9E%84%E5%92%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[概述1.SOA（Service Oriented Architecture）“面向服务的架构”:他是一种设计方法，其中包含多个服务， 服务之间通过相互依赖最终提供一系列的功能。一个服务通常以独立的形式存在与操作系统进程中。各个服务之间通过网络调用。 2.微服务架构:其实和 SOA 架构类似,微服务是在 SOA 上做的升华，微服务架构强调的一个重点是“业务需要彻底的组件化和服务化”，原有的单个业务系统会拆分为多个可以独立开发、设计、运行的小应用。这些小应用之间通过服务完成交互和集成。 微服务架构 = 80%的SOA服务架构思想 + 100%的组件化架构思想 + 80%的领域建模思想 SOA架构的特点系统集成：站在系统的角度，解决企业系统间的通信问 题，把原先散乱、无规划的系统间的网状结构，梳理成 规整、可治理的系统间星形结构，这一步往往需要引入一些产品，比如 ESB、以及技术规范、服务管理规范； 这一步解决的核心问题是【有序】 系统的服务化：站在功能的角度，把业务逻辑抽象成 可复用、可组装的服务，通过服务的编排实现业务的 快速再生，目的：把原先固有的业务功能转变为通用的业务服务，实现业务逻辑的快速复用；这一步解决 的核心问题是【复用】 业务的服务化：站在企业的角度，把企业职能抽象成 可复用、可组装的服务；把原先职能化的企业架构转变为服务化的企业架构，进一步提升企业的对外服务能力；“前面两步都是从技术层面来解决系统调用、系统功能复用的问题”。第三步，则是以业务驱动把一个业务单元封装成一项服务。这一步解决的核心问题是【高效】 微服务架构的特点通过服务实现组件化：开发者不再需要协调其它服务部署对本服务的影响。 按业务能力来划分服务和开发团队：开发者可以自由选择开发技术，提供 API 服务。 去中心化： 每个微服务有自己私有的数据库持久化业务数据 每个微服务只能访问自己的数据库，而不能访问其它服务的数据库 某些业务场景下，需要在一个事务中更新多个数据库。这种情况也不能直接访问其它微服务的数据库，而是通过对于微服务进行操作 数据的去中心化，进一步降低了微服务之间的耦合度，不同服务可以采用不同的数据库技术（SQL、NoSQL等）。在复杂的业务场景下，如果包含多个微服务，通常在客户端或者中间层（网关）处理 主要区别 微服务相比于SOA更加精细，微服务更多的以独立的进程的方式存在，互相之间并无影响； 微服务提供的接口方式更加通用化，例如REST方式，各种终端都可以调用，无关语言、平台限制； 微服务更倾向于分布式去中心化的部署方式，在互联网业务场景下更适合；]]></content>
      <categories>
        <category>9-网站架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>微服务</tag>
        <tag>SOA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud总结]]></title>
    <url>%2F2019%2F05%2F05%2Fspringcloud%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[概述 Spring Cloud是一个分布式服务框架 Spring Cloud是一系列框架的有序集合 Spring Cloud分布式微服务架构下的一站式解决方案 Spring Cloud是各个微服务架构落地技术的集合体 微服务微服务（Microservices）是一种架构风格。一个大型复杂软件应用由一个或多个微服务组成，每一个微服务提供单个业务功能的服务，每一个微服务仅关注于完成一件任务并很好地完成该任务，能够自行单独启动或销毁，拥有自己独立的数据库。 核心组件]]></content>
      <categories>
        <category>9-网站架构</category>
      </categories>
      <tags>
        <tag>spring cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站架构的发展演变]]></title>
    <url>%2F2019%2F05%2F04%2F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E7%9A%84%E5%8F%91%E5%B1%95%E6%BC%94%E5%8F%98%2F</url>
    <content type="text"><![CDATA[网站架构发展图 单一应用架构 当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。 此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。 适用于小型网站，小型管理系统，将所有功能都部署到一个功能里，简单易用。 缺点： 1.性能扩展比较难 2.协同开发问题3.不利于升级维护。 垂直应用架构 当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。 此时，用于加速前端页面开发的 Web框架(MVC) 是关键。 通过切分业务来实现各个模块独立部署，降低了维护和部署的难度，团队各司其职更易管理，性能扩展也更方便，更有针对性。 缺点：公用模块无法重复利用，开发性的浪费。 分布式服务架构 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。 此时，用于提高业务复用及整合的 分布式服务框架(RPC) 是关键。 流动计算架构 当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。 此时，用于提高机器利用率的资源调度和治理中心(SOA) 是关键。]]></content>
      <categories>
        <category>9-网站架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot整合redis作为缓存]]></title>
    <url>%2F2019%2F04%2F28%2Fspringboot%E6%95%B4%E5%90%88redis%E4%BD%9C%E4%B8%BA%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[Redis常用的五大数据类型String【字符串】、List【列表】、Set【集合】、Hash【散列】、ZSet【有序集合】 Redis的Template分为两种一种是StringRedisTemplate，另一种是RedisTemplate 两者的关系是StringRedisTemplate继承RedisTemplate。 两者的数据是不共通的；也就是说StringRedisTemplate只能管理StringRedisTemplate里面的数据，RedisTemplate只能管理RedisTemplate中的数据。 SDR默认采用的序列化策略有两种，一种是String的序列化策略，一种是JDK的序列化策略。 StringRedisTemplate默认采用的是String的序列化策略，保存的key和value都是采用此策略序列化保存的。 RedisTemplate默认采用的是JDK的序列化策略，保存的key和value都是采用此策略序列化保存的。 大致的操作分为这5种，以StringRedisTemplate为例12345stringRedisTemplate.opsForValue() --StringstringRedisTemplate.opsForList() --ListstringRedisTemplate.opsForSet() --SetstringRedisTemplate.opsForHash() --HashstringRedisTemplate.opsForZset() -Zset 整合redis1.导入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 2.修改配置文件spring.redis.host=192.168.126.129 3.创建redis配置类1234567891011121314151617181920212223@Configurationpublic class RedisConfig &#123; @Bean public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) &#123; RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(connectionFactory); //使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值 Jackson2JsonRedisSerializer serializer = new Jackson2JsonRedisSerializer(Object.class); ObjectMapper mapper = new ObjectMapper(); mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); serializer.setObjectMapper(mapper); template.setValueSerializer(serializer); //使用StringRedisSerializer来序列化和反序列化redis的key值 template.setKeySerializer(new StringRedisSerializer()); template.afterPropertiesSet(); return template; &#125;&#125; 4.service层应用缓存123456789101112131415161718192021222324252627282930313233343536373839404142@Servicepublic class PersonService &#123; @Autowired private PersonRepo personRepo; /** * @Cacheable 应用到读取数据的方法上，先从缓存中读取，如果没有再从DB获取数据，然后把数据添加到缓存中 * unless 表示条件表达式成立的话不放入缓存 * @param username * @return */ @Cacheable(value = "user", key = "#root.targetClass + #username", unless = "#result eq null") public Person getPersonByName(String username) &#123; Person person = personRepo.getPersonByName(username); return person; &#125; /** * @CachePut 应用到写数据的方法上，如新增/修改方法，调用方法时会自动把相应的数据放入缓存 * @param person * @return */ @CachePut(value = "user", key = "#root.targetClass + #result.username", unless = "#person eq null") public Person savePerson(Person person) &#123; return personRepo.savePerson(person); &#125; /** * @CacheEvict 应用到删除数据的方法上，调用方法时会从缓存中删除对应key的数据 * @param username * @return */ @CacheEvict(value = "user", key = "#root.targetClass + #username", condition = "#result eq true") public boolean removePersonByName(String username) &#123; return personRepo.removePersonByName(username) &gt; 0; &#125; public boolean isExistPersonName(Person person) &#123; return personRepo.existPersonName(person) &gt; 0; &#125;&#125;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot缓存]]></title>
    <url>%2F2019%2F04%2F28%2Fspringboot%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[JSR107缓存规范 CachingProvider 定义了创建、配置、获取、管理和控制多个CacheManager。一个应用可以在运行期间访问多个CachingProvider CacheManager 定义了创建、配置、获取、管理和控制多个唯一命名的Cache,这些Cache存在于CacheManage的上下文中，一个CacheManage只被一个CachingProvider拥有 Cache 类似于Map的数据结构并临时储存以key为索引的值，一个Cache仅仅被一个CacheManage所拥有 Entry 存储在Cache中的key-value对 Expiry 存储在Cache的条目有一个定义的有效期，一旦超过这个时间，就会设置过期的状态，过期无法被访问，更新，删除。缓存的有效期可以通过ExpiryPolicy设置 如下图： Spring的缓存抽象 功能 Cache 缓存接口，定义缓存操作，实现有：RedisCache、EhCacheCache、ConcurrentMapCache等 CacheManager 缓存管理器，管理各种缓存（Cache）组件 @Cacheable 针对方法配置，根据方法的请求参数对其结果进行缓存 @CacheEvict 清空缓存 @CachePut 先调用方法，然后更新缓存 @EnableCaching 开启基于注解的缓存 KeyGenerator 缓存数据时key生成的策略 serialize 缓存数据时value序列化策略]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8新特性之Optional]]></title>
    <url>%2F2019%2F04%2F27%2FJava8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BOptional%2F</url>
    <content type="text"><![CDATA[概述Java8引入了Optional类。Optional类主要解决的问题是空指针异常。本质上，这是一个包含有可选值的包装类，这意味着Optional类既可以含有对象也可以为空。Optional是个容器，它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空指针检测。 常用方法 方法 描述 static Optional empty() 返回空的 Optional 实例 T get() 如果在这个Optional中包含这个值，返回值，否则抛出异常：NoSuchElementException boolean isPresent() 如果值存在则方法会返回true，否则返回 false static Optional of(T value) 返回一个指定非null值的Optional static Optional ofNullable(T value) 如果为非空，返回 Optional 描述的指定值，否则返回空的 Optional T orElse(T other) 如果存在该值，返回值， 否则返回 other boolean equals(Object obj) 判断其他对象是否等于 Optional Optional filter(Predicate&lt;? super predicate) 如果值存在，并且这个值匹配给定的 predicate，返回一个Optional用以描述这个值，否则返回一个空的Optional int hashCode() 返回存在值的哈希码，如果值不存在 返回 0 void ifPresent(Consumer&lt;? super T&gt; consumer) 如果值存在则使用该值调用 consumer , 否则不做任何事情 T orElseGet(Supplier&lt;? extends T&gt; other) 如果存在该值，返回值， 否则触发 other，并返回 other 调用的结果 T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) 如果存在该值，返回包含的值，否则抛出由 Supplier 继承的异常]]></content>
      <categories>
        <category>1-基础</category>
      </categories>
      <tags>
        <tag>Java8</tag>
        <tag>Optional</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot整合JPA]]></title>
    <url>%2F2019%2F04%2F27%2Fjpa%2F</url>
    <content type="text"><![CDATA[概述JPA: Java Persistence API,即Java持久层API。作用是使应用程序以统一的方式访问持久层。 SpringData JPA 整合JPA1.引入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt; 2.在application.yml文件中配置123456789101112spring: datasource: url: jdbc:mysql://127.0.0.1:3306/mytmall username: root password: admin driver-class-name: com.mysql.cj.jdbc.Driver jpa: hibernate: # 更新或者创建数据表结构 ddl-auto: update # 控制台显示SQL show-sql: true 3.创建一个实体类1234567891011121314//使用JPA注解配置映射关系@Entity //告诉JPA这是一个实体类（和数据表映射的类）@Table(name = "tbl_user") //@Table来指定和哪个数据表对应;如果省略默认表名就是user；public class User &#123; @Id //这是一个主键 @GeneratedValue(strategy = GenerationType.IDENTITY)//自增主键 private Integer id; @Column(name = "last_name",length = 50) //这是和数据表对应的一个列 private String lastName; @Column //省略默认列名就是属性名 private String email; 4.创建一个DAO接口123//继承JpaRepository来完成对数据库的操作public interface UserDAO extends JpaRepository&lt;User,Integer&gt; &#123;&#125; 5.编写一个controller123456789101112131415161718@RestControllerpublic class UserController &#123; @Autowired UserRepository userDAO; @GetMapping("/user/&#123;id&#125;") public User getUser(@PathVariable("id") Integer id) &#123; User user = userDAO.findOne(id); return null; &#125; @GetMapping("/user") public User insertUser(User user) &#123; User save = userDAO.save(user); return save; &#125;&#125;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>JPA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[B树和B+树]]></title>
    <url>%2F2019%2F04%2F26%2Fb%E6%A0%91%E5%92%8Cb%2B%E6%A0%91%2F</url>
    <content type="text"><![CDATA[概述动态查找树主要有二叉查找树（Binary Search Tree），平衡二叉查找树（Balanced Binary Search Tree）， 红黑树 (Red-Black Tree )。查找的时间复杂度 O(logN) 与树的深度相关，降低树的深度会提高查找效率，于是有了多路的B-tree和B+-tree。 B树是一种多路搜索树（并不是二叉的）对于一个M阶的B树，有以下生成策略： 定义任意非叶子结点最多只有M个儿子；且M&gt;2； 根结点的儿子数为[2, M]； 除根结点以外的非叶子结点的儿子数为[M/2, M]； 每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字） 非叶子结点的关键字个数=指向儿子的指针个数-1； 非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]； 非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树； 所有叶子结点位于同一层； 例如：M=3 B树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点。 B树的特性： 关键字集合分布在整颗树中； 任何一个关键字出现且只出现在一个结点中； 搜索有可能在非叶子结点结束； 其搜索性能等价于在关键字全集内做一次二分查找； 自动层次控制； B+树B+树是B-树的变体，也是一种多路搜索树： 非叶子结点的子树指针与关键字个数相同； 非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）； 为所有叶子结点增加一个链指针； 例如：M=3 B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中，其性能也等价于在关键字全集做一次二分查找。 B+的特性： 所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的； 不可能在非叶子结点命中； 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层； 更适合文件索引系统； 区别B树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点，所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；B+树：在B树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引，B+树总是到叶子结点才命中；]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker]]></title>
    <url>%2F2019%2F04%2F23%2Fdocker%2F</url>
    <content type="text"><![CDATA[概述Docker是一个开源的应用容器引擎它与传统的虚拟机不同，如下图所示： 核心概念 docker主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）； docker客户端(Client)：连接docker主机进行操作； docker仓库(Registry)：用来保存各种打包好的软件镜像； docker镜像(Images)：软件打包好的镜像；放在docker仓库中； docker容器(Container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用 如下图所示： 基本使用 安装Docker 去Docker仓库找到这个软件对应的镜像 使用Docker运行这个镜像，这个镜像就会生成一个Docker容器 对容器的启动停止就是对软件的启动停止 容器使用12345678910111213141516171819202122#1、搜索镜像docker search tomcat#2、拉取镜像[root@localhost ~]# docker pull tomcat#3、根据镜像启动容器docker run --name mytomcat -d tomcat:latest#4、查看运行中的容器docker ps #5、停止运行中的容器docker stop 容器的id#6、查看所有的容器docker ps -a#7、启动容器docker start 容器id#8、删除一个容器docker rm 容器id#9、启动一个做了端口映射的tomcatdocker run -d -p 8080:8080 tomcat#-d：后台运行#-p: 将主机的端口映射到容器的一个端口 主机端口:容器内部的端口#10、查看容器的日志docker logs container-name/container-id]]></content>
      <categories>
        <category>7-工具</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL存储引擎]]></title>
    <url>%2F2019%2F04%2F20%2Fmysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[概述MySQL有两种表类型分别是MyISAM和InnoDB。5.5版之前，MySQL的默认存储引擎是MyISAM，5.5版本之后，MySQL引入了InnoDB。 MyISAM特点 不支持行锁(MyISAM只有表锁) 不支持事务 不支持外键 不支持崩溃后的安全恢复 支持全文索引 属于堆表，索引和数据分离。.frm 用于存储表的定义；.MYD 用于存放数据；.MYI 用于存放表索引 补充：表级锁： 每次操作锁住整张表。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；行级锁： 每次操作锁住一行数据。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高； InnoDB特点 支持行锁，采用MVCC来支持高并发，有可能死锁 支持事务 支持外键 支持崩溃后的安全恢复 不支持全文索引 属于索引组织表，索引和数据不分离。 补充：innodb有两种存储方式，共享表空间存储和多表空间存储两种存储方式的表结构和myisam一样，以表名开头，扩展名是.frm。如果使用共享表空间，那么所有表的数据文件和索引文件都保存在一个表空间里，一个表空间可以有多个文件，一般共享表空间的名字叫ibdata1-n。如果使用多表空间，那么每个表都有一个表空间文件用于存储每个表的数据和索引，文件名以表名开头，以.ibd为扩展名。 为什么MyISAM会比Innodb 的查询速度快InnoDB 在做SELECT的时候，要维护的东西比MYISAM引擎多很多： InnoDB 要缓存数据和索引，MyISAM只缓存索引块，这中间还有换进换出的减少 innodb寻址要映射到块，再到行，MyISAM记录的直接是文件的OFFSET，定位比INNODB要快 InnoDB 还需要维护MVCC一致 MyISAM索引实现MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。如图： InnoDB索引实现虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。如图： 使用场景MyISAM更适合读密集的表，而InnoDB更适合写密集的的表。 在数据库做主从分离的情况下，经常选择MyISAM作为主库的存储引擎。一般来说，如果需要事务支持，并且有较高的并发读取频率(由于MyISAM的表锁的粒度太大，所以当该表写并发量较高时，要等待的查询就会很多了)，InnoDB是不错的选择。如果数据量很大（MyISAM支持压缩特性可以减少磁盘的空间占用），而且不需要支持事务时，MyISAM是最好的选择。]]></content>
      <categories>
        <category>5-数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>存储引擎</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring事务管理]]></title>
    <url>%2F2019%2F04%2F19%2F%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[概述 事务是一系列操作的集和。 事务中的每一个操作要么都执行成功，要么都不执行。 如果有一个操作执行失败，那么事务就会回滚到最开始的状态。 事务用来确保数据的完整性和一致性。 事务的特性事务有四个特征：ACID 原子性（Atomicity）：事务是最小的执行单位，不允许分割。事务的原子性确保操作要么全部执行，要么都不执行。 一致性（Consistency）：执行事务前后，数据保持一致，多个，多个事务对同一个数据读取的结果是相同的。 隔离性（Isolation）：并发访问数据库时，一个用户的事务不被其他事务所干扰。 持久性（Durability）：一旦事务完成，无论发生什么系统错误，它的结果都不应该受到影响，这样就能从任何系统崩溃中恢复过来。通常情况下，事务的结果被写到持久化存储器中。 Spring 编程式事务和声明式事务的区别 编程式事务：所谓编程式事务指的是通过编码方式实现事务，允许用户在代码中精确定义事务的边界。即类似于JDBC编程实现事务管理。管理使用TransactionTemplate或者直接使用底层的PlatformTransactionManager。对于编程式事务管理，spring推荐使用TransactionTemplate。 声明式事务：声明式事务基于Spring AOP,底层创建动态代理对象，在代码的开头结尾封装了开启事务和事务回滚操作。声明式事务最大的优点就是不需要通过编程的方式管理事务，这样就不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明(或通过基于@Transactional注解的方式)，便可以将事务规则应用到业务逻辑中。 简单地说，编程式事务侵入到了业务代码里面，但是提供了更加详细的事务管理；而声明式事务由于基于AOP，所以既能起到事务管理的作用，又可以不影响业务代码的具体实现。 并发事务带来的问题在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对统一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。 脏读（Dirty read）: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。 丢失修改（Lost to modify）: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。 不可重复读（Unrepeatableread）: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。 幻读（Phantom read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。 不可重复度和幻读区别：不可重复读的重点是修改，幻读的重点在于新增或者删除。 事务隔离级别 READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读 READ-COMMITTED(读取已提交): 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生 REPEATABLE-READ（可重复读）: 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。 SERIALIZABLE(可串行化): 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。 事务传播行为所谓事务的传播行为是指，当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。此时有若干选项可以指定一个事务性方法的执行行为。 REQUIRED ：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。 SUPPORTS ：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。 MANDATORY ：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。 REQUIRES_NEW ：创建一个新的事务，如果当前存在事务，则把当前事务挂起。 NOT_SUPPORTED ：以非事务方式运行，如果当前存在事务，则把当前事务挂起。 NEVER ：以非事务方式运行，如果当前存在事务，则抛出异常。 NESTED ：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于 REQUIRED 。 指定方法：通过使用 propagation 属性设置，例如：@Transactional(propagation = Propagation.REQUIRED)]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>事务管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[悲观锁与乐观锁]]></title>
    <url>%2F2019%2F04%2F16%2F%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81%2F</url>
    <content type="text"><![CDATA[悲观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次拿数据的时候都会上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。 乐观锁总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。乐观锁有两种实现方式，分别是使用版本号机制和CAS算法。1.版本号机制一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值就会加一。当线程A要更新数据时，在读取数据的同时，也会读取version值，在提交更新时，若刚才读取到的version值与当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功为止。 2.CAS算法即compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS算法涉及到三个操作数 需要读写的内存值 V 进行比较的值 A 拟写入的新值 B 当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。 使用场景悲观锁适用于多写的场景；乐观锁适用于少写多读的场景。]]></content>
      <categories>
        <category>3-并发</category>
      </categories>
      <tags>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot与shiro的整合]]></title>
    <url>%2F2019%2F04%2F16%2Fshiro%2F</url>
    <content type="text"><![CDATA[概述Shiro是一个强大易用的Java安全框架,提供了认证、授权、加密和会话管理等功能。 shiro实现原理 Subject：主体，代表了当前“用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是Subject，如网络爬虫，机器人等；即一个抽象概念；所有Subject都绑定到SecurityManager，与Subject的所有交互都会委托给SecurityManager。 SecurityManager：安全管理器；即所有与安全有关的操作都会与SecurityManager交互；且它管理着所有Subject，是Shiro的核心。 Realm：域，Shiro与应用安全数据间的桥梁。 使用方法1.添加依赖12345&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; 2.自定义Realm类，继承AuthorizingRealm父类12345678910111213141516171819202122232425262728293031323334353637383940public class MyShiroRealm extends AuthorizingRealm &#123; @Autowired UserService userService; //权限管理 @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo(); User user = (User) principal.getPrimaryPrincipal(); try &#123; List&lt;SysRole&gt; roles = sysRoleService.selectByUid(user.getUid()); for (SysRole role : roles) &#123; authorizationInfo.addRole(role.getRolename()); &#125; List&lt;SysPermission&gt; permissions = sysPermissionService.selectByUid(user.getUid()); for(SysPermission permission : permissions)&#123; authorizationInfo.addStringPermission(permission.getPername()); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; return authorizationInfo; &#125; //身份认证 @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; //获取用户信息 String name = authenticationToken.getPrincipal().toString(); User user = userService.findUserByName(name); if (user == null) &#123; //这里返回后会报出对应异常 return null; &#125; else &#123; //这里验证authenticationToken和simpleAuthenticationInfo的信息 SimpleAuthenticationInfo simpleAuthenticationInfo = new SimpleAuthenticationInfo(name, user.getUserPwd(), getName()); return simpleAuthenticationInfo; &#125; &#125;&#125; 3.自定义SessionManager（前后端分离需要这一步）1234567891011121314151617181920212223public class MySessionManager extends DefaultWebSessionManager &#123; private static final String AUTHORIZATION = "Authorization"; public MySessionManager() &#123; super(); &#125; @Override protected Serializable getSessionId(ServletRequest request, ServletResponse response) &#123; //前端ajax的headers中必须传入Authorization的值 String id = WebUtils.toHttp(request).getHeader(AUTHORIZATION); //如果请求头中有 Authorization 则其值为sessionId if (!StringUtils.isEmpty(id)) &#123; request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID, id); request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID, Boolean.TRUE); return id; &#125; else &#123; //否则按默认规则从cookie取sessionId return super.getSessionId(request, response); &#125; &#125; &#125; 4.配置Shiro123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121@Configurationpublic class ShiroConfig &#123; /** * 一.请求拦截 * @param securityManager * @return */ @Bean public ShiroFilterFactoryBean shiroFilter(SecurityManager securityManager) &#123; ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); shiroFilterFactoryBean.setSecurityManager(securityManager); //拦截器. Map&lt;String,String&gt; filterChainDefinitionMap = new LinkedHashMap&lt;String,String&gt;(); //注意过滤器配置顺序 不能颠倒 //anon. 配置不会被拦截的请求 顺序判断 filterChainDefinitionMap.put("/logout", "anon"); filterChainDefinitionMap.put("/login", "anon"); //authc. 配置拦截的请求 filterChainDefinitionMap.put("/**", "authc"); //配置shiro默认登录界面地址，前后端分离中登录界面跳转应由前端路由控制，后台仅返回json数据 shiroFilterFactoryBean.setLoginUrl("/unauth"); shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap); return shiroFilterFactoryBean; &#125; /** * 二.权限管理 * @Title: securityManager * @Description: SecurityManager，权限管理，这个类组合了登陆，登出，权限，session的处理 * @return SecurityManager */ @Bean public SecurityManager securityManager() &#123; DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); securityManager.setRealm(myShiroRealm()); securityManager.setSessionManager(sessionManager()); //注入记住我管理器 securityManager.setRememberMeManager(rememberMeManager()); return securityManager; &#125; /** * 1.自定义认证 * @Title: myShiroRealm * @Description: ShiroRealm，这是个自定义的认证类，继承自AuthorizingRealm，负责用户的认证和权限的处理 * @return MyShiroRealm */ @Bean public MyShiroRealm myShiroRealm() &#123; MyShiroRealm myShiroRealm = new MyShiroRealm(); myShiroRealm.setCredentialsMatcher(hashedCredentialsMatcher()); return myShiroRealm; &#125; /** * 密码凭证匹配器，作为自定义认证的基础 * （由于我们的密码校验交给Shiro的SimpleAuthenticationInfo进行处理了 ） * @return */ @Bean public HashedCredentialsMatcher hashedCredentialsMatcher() &#123; HashedCredentialsMatcher hashedCredentialsMatcher = new HashedCredentialsMatcher(); hashedCredentialsMatcher.setHashAlgorithmName("MD5");//散列算法:这里使用MD5算法; hashedCredentialsMatcher.setHashIterations(1024);//散列的次数，比如散列两次，相当于 md5(md5("")); return hashedCredentialsMatcher; &#125; /** * 2.自定义sessionManager，用户的唯一标识，即Token或Authorization的认证 */ @Bean public SessionManager sessionManager() &#123; MySessionManager mySessionManager = new MySessionManager(); mySessionManager.setSessionDAO(redisSessionDAO()); return mySessionManager; &#125; /** * 配置shiro redisManager 使用的是shiro-redis开源插件 * * @return */ public RedisManager redisManager() &#123; RedisManager redisManager = new RedisManager(); redisManager.setHost(configCode.getRedisHost()); redisManager.setPort(configCode.getRedisPort()); redisManager.setExpire(configCode.getRedisExpire()); redisManager.setTimeout(configCode.getRedisTimeout()); return redisManager; &#125; @Bean public RedisSessionDAO redisSessionDAO() &#123; RedisSessionDAO redisSessionDAO = new RedisSessionDAO(); // 自定义session管理 使用redis redisSessionDAO.setRedisManager(redisManager()); return redisSessionDAO; &#125; /** * 3.此处对应前端“记住我”的功能，获取用户关联信息而无需登录 * @return */ @Bean public SimpleCookie rememberMeCookie()&#123; //这个参数是cookie的名称，对应前端的checkbox的name = remember SimpleCookie simpleCookie = new SimpleCookie("remember"); simpleCookie.setMaxAge(259200); return simpleCookie; &#125; @Bean public CookieRememberMeManager rememberMeManager()&#123; CookieRememberMeManager cookieRememberMeManager = new CookieRememberMeManager(); cookieRememberMeManager.setCookie(rememberMeCookie()); cookieRememberMeManager.setCipherKey(Base64.decode("one")); return cookieRememberMeManager; &#125;&#125; 5.编写Controller123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172@RestControllerpublic class UserController &#123; /** * 登录 * @param request * @param user * @return * @throws Exception */ @RequestMapping(value = "/login", method=RequestMethod.POST) @ResponseBody public RespEntity&lt;String&gt; doLogin(HttpServletRequest request, @RequestBody SysUser user) throws Exception &#123; RespEntity&lt;String&gt; result = new RespEntity&lt;String&gt;(); try &#123; Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken(user.getUsername(), user.getPassword()); subject.login(token); String authorization = (String) subject.getSession().getId(); result.setHttpCode(HttpCode.Success); result.setData(authorization); //将authorization传给前端，用于MySessionManager中请求的验证 result.setMessage("登陆成功"); &#125; catch (IncorrectCredentialsException e) &#123; result.setMessage("密码错误"); &#125; catch (LockedAccountException e) &#123; result.setMessage("该用户已被禁用"); &#125; catch (AuthenticationException e) &#123; result.setMessage("该用户不存在"); &#125; return result; &#125; /** * 注销 * @param request * @return * @throws Exception */ @RequestMapping(value = "/logout") @ResponseBody public RespEntity&lt;String&gt; logout(HttpServletRequest request) throws Exception &#123; RespEntity&lt;String&gt; resp = new RespEntity&lt;&gt;(); Subject currentUser = SecurityUtils.getSubject(); currentUser.logout(); resp.setHttpCode(HttpCode.Success); resp.setMessage("注销成功"); return resp; &#125; /** * 未登录 * @param request * @return * @throws Exception */ @RequestMapping(value = "/unauth") @ResponseBody public RespEntity&lt;String&gt; unauth(HttpServletRequest request) throws Exception &#123; RespEntity&lt;String&gt; resp = new RespEntity&lt;&gt;(); resp.setHttpCode(HttpCode.Noauth); resp.setMessage("重新登录"); return resp; &#125; @RequestMapping(value = "/error") @ResponseBody public RespEntity&lt;String&gt; error(HttpServletRequest request) throws Exception &#123; RespEntity&lt;String&gt; resp = new RespEntity&lt;&gt;(); resp.setHttpCode(HttpCode.Error); resp.setMessage("服务器异常"); return resp; &#125; &#125;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>shiro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之单例模式]]></title>
    <url>%2F2019%2F04%2F15%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[概述单例模式即保证一个类仅有一个实例，并提供一个访问它的全局访问点。它有以下两个好处： 对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销。 由于new操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻GC压力，缩短GC停顿时间。 单例模式的实现单例模式有两种实现方式： 饿汉方式。指全局的单例实例在类装载时构建 懒汉方式。指全局的单例实例在第一次被使用时构建 饿汉方式（线程安全）123456789public class Singleton &#123; //在静态初始化器中创建单例实例，这段代码保证了线程安全 private static Singleton uniqueInstance = new Singleton(); //Singleton类只有一个构造方法并且是被private修饰的，所以用户无法通过new方法创建该对象实例 private Singleton()&#123;&#125; public static Singleton getInstance()&#123; return uniqueInstance; &#125;&#125; 所谓 “饿汉方式” 就是说JVM在加载这个类时就马上创建此唯一的单例实例，不管你用不用，先创建了再说，如果一直没有被使用，便浪费了空间，典型的空间换时间，每次调用的时候，就不需要再判断，节省了运行时间。 懒汉方式所谓 “ 懒汉式” 就是说单例实例在第一次被使用时构建，而不是在JVM在加载这个类时就马上创建此唯一的单例实例。此方式有线程安全和非线程安全两个版本。1.非线程安全版本12345678910111213public class Singleton &#123; private static Singleton uniqueInstance; private Singleton ()&#123; &#125; //没有加入synchronized关键字的版本是线程不安全的 public static Singleton getInstance() &#123; //判断当前单例是否已经存在，若存在则返回，不存在则再建立单例 if (uniqueInstance == null) &#123; uniqueInstance = new Singleton(); &#125; return uniqueInstance; &#125; &#125; 2.双重检查加锁线程安全版本1234567891011121314151617181920public class Singleton &#123; //volatile保证，当uniqueInstance变量被初始化成Singleton实例时，多个线程可以正确处理uniqueInstance变量 private volatile static Singleton uniqueInstance; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; //检查实例，如果不存在，就进入同步代码块 if (uniqueInstance == null) &#123; //只有第一次才彻底执行这里的代码 synchronized(Singleton.class) &#123; //进入同步代码块后，再检查一次，如果仍是null，才创建实例 if (uniqueInstance == null) &#123; uniqueInstance = new Singleton(); &#125; &#125; &#125; return uniqueInstance; &#125;&#125;]]></content>
      <categories>
        <category>6-设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发之synchronized]]></title>
    <url>%2F2019%2F04%2F13%2Fsynchronized%2F</url>
    <content type="text"><![CDATA[概述 Java中的每一个对象都有且只有一个锁 每一个线程在执行被synchronized关键字控制的代码之前，都要先获取相应的锁，也称为监视器（monitor） 没有获取到锁的线程只能等待 每个对象拥有一个计数器，当线程获取该对象锁后，计数器就会加一，释放锁后就会将计数器减一 synchronized关键字最主要的三种使用方式 JDK1.6 之后的底层优化JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。 锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。 偏向锁引入偏向锁的目的和引入轻量级锁的目的很像，他们都是为了没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。但是不同是：轻量级锁在无竞争的情况下使用 CAS 操作去代替使用互斥量。而偏向锁在无竞争的情况下会把整个同步都消除掉。 偏向锁的“偏”就是偏心的偏，它的意思是会偏向于第一个获得它的线程，如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步！ 但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。 轻量级锁倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)。轻量级锁不是为了代替重量级锁，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，因为使用轻量级锁时，不需要申请互斥量。另外，轻量级锁的加锁和解锁都用到了CAS操作。 轻量级锁能够提升程序同步性能的依据是“对于绝大部分锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥操作的开销。但如果存在锁竞争，除了互斥量开销外，还会额外发生CAS操作，因此在有锁竞争的情况下，轻量级锁比传统的重量级锁更慢！如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁！ 自旋锁和自适应自旋轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。 互斥同步对性能最大的影响就是阻塞的实现，因为挂起线程/恢复线程的操作都需要转入内核态中完成（用户态转换到内核态会耗费时间）。 一般线程持有锁的时间都不是太长，所以仅仅为了这一点时间去挂起线程/恢复线程是得不偿失的。 所以，虚拟机的开发团队就这样去考虑：“我们能不能让后面来的请求获取锁的线程等待一会而不被挂起呢？看看持有锁的线程是否很快就会释放锁”。为了让一个线程等待，我们只需要让线程执行一个忙循环（自旋），这项技术就叫做自旋。 锁消除锁消除理解起来很简单，它指的就是虚拟机即使编译器在运行时，如果检测到那些共享数据不可能存在竞争，那么就执行锁消除。锁消除可以节省毫无意义的请求锁的时间。 锁粗化原则上，在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小，——直在共享数据的实际作用域才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待线程也能尽快拿到锁。 大部分情况下，上面的原则都是没有问题的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，那么会带来很多不必要的性能消耗。 Synchronized 和 ReenTrantLock 的对比两者都是可重入锁两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。 synchronized 依赖于 JVM 而 ReenTrantLock 依赖于 APIsynchronized 是依赖于 JVM 实现的。ReenTrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock 方法配合 try/finally 语句块来完成）。 ReenTrantLock 比 synchronized 增加了一些高级功能相比synchronized，ReenTrantLock增加了一些高级功能。主要来说主要有三点：①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件） ReenTrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。 ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。 ReenTrantLock默认情况是非公平的，可以通过 ReenTrantLock类的ReentrantLock(boolean fair)构造方法来制定是否是公平的。 synchronized关键字与wait()和notify/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知” ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。 性能已不是选择标准在JDK1.6之前，synchronized 的性能是比 ReenTrantLock 差很多。具体表示为：synchronized 关键字吞吐量随线程数的增加，下降得非常严重。而ReenTrantLock 基本保持一个比较稳定的水平。在 JDK1.6 之后 JVM 团队对 synchronized 关键字做了很多优化。JDK1.6 之后，synchronized 和 ReenTrantLock 的性能基本是持平了。JDK1.6之后，性能已经不是选择synchronized和ReenTrantLock的影响因素了！而且虚拟机在未来的性能改进中会更偏向于原生的synchronized，所以还是提倡在synchronized能满足你的需求的情况下，优先考虑使用synchronized关键字来进行同步！优化后的synchronized和ReenTrantLock一样，在很多地方都是用到了CAS操作。]]></content>
      <categories>
        <category>3-并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
        <tag>synchronized</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解Java虚拟机之垃圾回收]]></title>
    <url>%2F2019%2F04%2F08%2Fgc%2F</url>
    <content type="text"><![CDATA[概述垃圾收集主要是针对堆和方法区进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。 Java堆的基本结构Java 堆是垃圾收集器管理的主要区域，因此也被称作GC堆（Garbage Collected Heap）.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden空间、From Survivor、To Survivor空间等。进一步划分的目的是更好地回收内存，或者更快地分配内存。 如上图所示，eden区、s0区、s1区都属于新生代，tentired 区属于老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden区-&gt;Survivor 区后对象的初始年龄变为1)，当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。 堆内存常见分配策略 对象优先在Eden区分配 大对象直接进入老年代 长期存活的对象将进入老年代 判断一个对象是否需要被回收引用计数法给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；计数器为0的对象就是可以被回收的。在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为循环引用的存在，因此目前的主流 Java 虚拟机不使用引用计数算法。 可达性分析算法以 GC Roots 为起始点进行搜索，所走过的路径称为引用链，可达的对象都是存活的，不可达的对象可被回收。GC Roots 一般包含以下内容： 虚拟机栈中局部变量表中引用的对象 本地方法栈中 JNI 中引用的对象 方法区中类静态属性引用的对象 方法区中的常量引用的对象 方法区的回收因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。主要是对常量池的回收和对类的卸载。为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载： 该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。 加载该类的 ClassLoader 已经被回收。 该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。 引用类型JDK1.2以后，Java对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）。 强引用被强引用关联的对象不会被回收。当内存空间不足时，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。使用 new 的方式来创建强引用。Object obj = new Object(); 软引用被软引用关联的对象只有在内存不够的情况下才会被回收。使用 SoftReference 类来创建软引用。123Object obj = new Object();SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(obj);obj = null; // 使对象只被软引用关联 弱引用被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。使用 WeakReference 类来创建弱引用。123Object obj = new Object();WeakReference&lt;Object&gt; wf = new WeakReference&lt;Object&gt;(obj);obj = null; 虚引用又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。使用 PhantomReference 来创建虚引用。123Object obj = new Object();PhantomReference&lt;Object&gt; pf = new PhantomReference&lt;Object&gt;(obj, null);obj = null; 垃圾收集算法标记-清除算法标记要回收的对象，然后清除。不足： 标记和清除过程效率都不高； 会产生大量不连续的内存碎片，导致无法给大对象分配内存。 标记-整理算法让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。优点:不会产生内存碎片。不足:需要移动大量对象，处理效率比较低。 复制算法将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间一次清理掉。 分代收集算法它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。一般将堆分为新生代和老年代。新生代使用：复制算法老年代使用：标记 - 清除 或者 标记 - 整理 算法 垃圾收集器Serial收集器Serial（串行）收集器收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ “Stop The World” ），直到它收集结束。 新生代采用复制算法，老年代采用标记-整理算法。 虚拟机的设计者们当然知道Stop The World带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。 但是Serial收集器有没有优于其他垃圾收集器的地方呢？当然有，它简单而高效（与其他收集器的单线程相比）。Serial收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial收集器对于运行在Client模式下的虚拟机来说是个不错的选择。 ParNew收集器ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器完全一样。 新生代采用复制算法，老年代采用标记-整理算法。 它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器（真正意义上的并发收集器，后面会介绍到）配合工作。 并行和并发概念补充： 并行（Parallel） ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。 并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个CPU上。 Parallel Scavenge收集器Parallel Scavenge 收集器类似于ParNew 收集器。 那么它有什么特别之处呢？ -XX:+UseParallelGC 使用Parallel收集器+ 老年代串行 -XX:+UseParallelOldGC 使用Parallel收集器+ 老年代并行 Parallel Scavenge收集器关注点是吞吐量（高效率的利用CPU）。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。 Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，手工优化存在的话可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。 新生代采用复制算法，老年代采用标记-整理算法。 Serial Old收集器Serial收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用途：一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备方案。 Parallel Old收集器Parallel Scavenge收集器的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器。 CMS收集器CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它而非常符合在注重用户体验的应用上使用。 CMS（Concurrent Mark Sweep）收集器是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。 从名字中的Mark Sweep这两个词可以看出，CMS收集器是一种 “标记-清除”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤： 初始标记： 暂停所有的其他线程，并记录下直接与root相连的对象，速度很快 ；并发标记： 同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短并发清除： 开启用户线程，同时GC线程开始对为标记的区域做清扫。CMS垃圾收集器 从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：并发收集、低停顿。但是它有下面三个明显的缺点： 对CPU资源敏感；无法处理浮动垃圾；它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。 G1收集器G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征. 被视为JDK1.7中HotSpot虚拟机的一个重要进化特征。它具备一下特点： 并行与并发：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。 分代收集：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。 空间整合：与CMS的“标记–清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。 可预测的停顿：这是G1相对于CMS的另一个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内。 G1收集器的运作大致分为以下几个步骤： 初始标记 并发标记 最终标记 筛选回收G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字Garbage-First的由来)。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了GF收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。]]></content>
      <categories>
        <category>4-JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java对象的创建、布局以及访问]]></title>
    <url>%2F2019%2F04%2F08%2Fjava%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Java对象的创建 类加载检查： 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。 分配内存： 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择那种分配方式由 Java 堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。 初始化零值： 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。 设置对象头： 初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。 执行 init 方法： 把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。 Java对象的内存布局在 Hotspot 虚拟机中，对象在内存中的布局可以分为3块区域：对象头、实例数据和对齐填充。 对象头(Header)：包含两部分，第一部分用于存储对象自身的运行时数据，如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等，32 位虚拟机占 32 bit，64 位虚拟机占 64 bit。官方称为 ‘Mark Word’。第二部分是类型指针，即对象指向它的类的元数据指针，虚拟机通过这个指针确定这个对象是哪个类的实例。另外，如果是 Java 数组，对象头中还必须有一块用于记录数组长度的数据，因为普通对象可以通过 Java 对象元数据确定大小，而数组对象不可以。 实例数据(Instance Data)：程序代码中所定义的各种类型的字段内容(包含父类继承下来的和子类中定义的)。 对齐填充(Padding)：不是必然需要，主要是占位，保证对象大小是某个字节的整数倍。 Java对象的访问定位使用对象时，通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有句柄和直接指针两种。 句柄：Java堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。 直接指针：reference 中存储的直接就是对象的地址。 比较：使用句柄的最大好处是 reference 中存储的是稳定的句柄地址，在对象移动(GC)是只改变实例数据指针地址，reference 自身不需要修改。直接指针访问的最大好处是速度快，节省了一次指针定位的时间开销。如果是对象频繁 GC 那么句柄方法好，如果是对象频繁访问则直接指针访问好。]]></content>
      <categories>
        <category>4-JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解Java虚拟机之Java内存区域]]></title>
    <url>%2F2019%2F04%2F08%2Fjava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[Java内存区域（Java运行时数据区域） 程序计数器 内存空间小，线程私有，时当前线程所执行的字节码的信号指示器。 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行指令的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器完成。 如果线程正在执行一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器的值则为Undefined。 程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域。 Java虚拟机栈 线程私有，生命周期和线程一致。 描述的是 Java 方法执行的内存模型：每个方法在执行时都会床创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程。 Java方法有两种返回方式，不管哪种返回方式都会导致栈帧被弹出。 return 语句 抛出异常 局部变量表存放了编译期可知的各种基本类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference 类型)和 returnAddress 类型(指向了一条字节码指令的地址)。 StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度。 OutOfMemoryError：如果虚拟机栈可以动态扩展，而扩展时无法申请到足够的内存。 本地方法栈 区别于 Java 虚拟机栈的是，Java 虚拟机栈为虚拟机执行 Java 方法服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 有 StackOverflowError 和 OutOfMemoryError 异常。 Java堆 Java 虚拟机所管理的内存中最大的一块。 线程共享，在虚拟机启动时创建。 此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。 方法区 线程共享。 存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 运行时常量池 属于方法区一部分。 用于存放编译期生成的各种字面量和符号引用。 内存有限，无法申请时抛出 OutOfMemoryError。]]></content>
      <categories>
        <category>4-JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>虚拟机</tag>
        <tag>内存区域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis总结]]></title>
    <url>%2F2019%2F04%2F06%2Fredis%2F</url>
    <content type="text"><![CDATA[概述Redis是一个基于内存的高性能key-value数据库。因此 redis 被广泛应用于缓存方向。另外，redis 也经常用来做分布式锁。redis 提供了多种数据类型来支持不同的业务场景。除此之外，redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。 使用Redis有哪些好处 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1) 支持丰富数据类型，支持string，list，set，sorted set，hash 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除 redis 和 memcached 的区别 Redis为什么是单线程的因为CPU不是Redis的瓶颈。Redis的瓶颈最有可能是机器内存或者网络带宽。]]></content>
      <categories>
        <category>5-数据库</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单页应用和多页应用]]></title>
    <url>%2F2019%2F04%2F02%2Fspa%2F</url>
    <content type="text"><![CDATA[概述常见web应用有两种开发模式，分别是单页应用模式SPA和多页应用模式MPA。两种模式各有优缺点。 多页应用每一次页面跳转的时候，后台服务器都会返回一个新的html文档，这种类型的网站也就是多页网站，也叫做多页应用。 它具有以下几个特点： 首屏加载快：当我们访问页面的时候，服务器返回一个html，页面就会展示出来，这个过程只经历了一个HTTP请求，所以页面展示的速度非常快。 搜索引擎优化效果较好：搜索引擎在做网页排名的时候，要根据网页内容才能给网页权重，来进行网页的排名。搜索引擎是可以识别html内容的，而我们每个页面所有的内容都放在Html中，所以这种多页应用，seo排名效果好。 页面切换慢：因为每次跳转都需要发出一个http请求，如果网络比较慢，在页面之间来回跳转时，就会发现明显的卡顿。 单页应用只有第一次进入页面的时候会请求一个html文件。当要切换其他页面时，路径也有相应的变化，页面内容进行了更新，但是并没有新的html文件请求，而仅仅是通过Ajax与服务器异步交换了所需要的数据。原理是：JS会感知到url的变化，通过这一点，可以用js动态的将当前页面的内容清除掉，然后将下一个页面的内容挂载到当前页面上，这个时候的路由不是后端来做了，而是前端来做，判断页面到底是显示哪个组件，清除不需要的，显示需要的组件，这种过程就是单页应用。 它具有以下几个特点： 首屏加载稍慢：首屏时需要请求一次html，然后还要发送一次Ajax异步请求，两次请求回来了，首屏才会展示出来。相对于多页应用，首屏时间稍慢。 SEO差：因为搜索引擎只认识html里的内容，不认识js的内容，而单页应用的内容都是靠js渲染生成出来的，搜索引擎不识别这部分内容，也就不会给一个好的排名，会导致单页应用做出来的网页在百度和谷歌上的排名差。 页面切换快：因为切换页面时，只对部分数据进行了异步请求然后更新内容，并不像多页应用那样请求的是一个完整的HTML，所以页面切换快。]]></content>
      <categories>
        <category>9-网站架构</category>
      </categories>
      <tags>
        <tag>SPA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axios的基本使用]]></title>
    <url>%2F2019%2F03%2F29%2Faxios%2F</url>
    <content type="text"><![CDATA[概述axios是一个基于promise可以用于浏览器和node.js的HTTP库。它具有以下特点： 支持浏览器和node.js 支持promise 能拦截请求和响应 能转换请求和响应数据 能取消请求 自动转换JSON数据 浏览器端支持防止CSRF(跨站请求伪造) 安装 npm:$ npm install axios bower:$ bower install axios cdn:&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; 使用1.发起一个GET请求 123456789101112131415161718192021// Make a request for a user with a given IDaxios.get('/user?ID=12345') .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;);// Optionally the request above could also be done asaxios.get('/user', &#123; params: &#123; ID: 12345 &#125; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); 2.发送一个POST请求 12345678910axios.post('/user', &#123; firstName: 'Fred', lastName: 'Flintstone' &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); 响应组成1234567891011121314151617181920&#123; // 服务端返回的数据 data: &#123;&#125;, // 服务端返回的状态码 status: 200, // 服务端返回的状态信息 statusText: 'OK', // 响应头 // 所有的响应头名称都是小写 headers: &#123;&#125;, // axios请求配置 config: &#123;&#125;, // 请求 request: &#123;&#125;&#125;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是前后端分离？]]></title>
    <url>%2F2019%2F03%2F27%2F%E4%BB%80%E4%B9%88%E6%98%AF%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[前后端不分离在前后端不分离的架构中，所有的静态资源和业务代码统一部署在同一台服务器上。服务器接收到浏览器请求后，进行处理和数据库查询，然后将得到的数据渲染到静态页面上，最后返回给浏览器。具体架构如下： 前后端分离前后端分离的架构中，静态资源和业务代码分别部署在两台服务器上。利用node.js的express框架作为一个中间层服务器进行请求的转发与视图解析。具体框架如下： 改变 服务器一分为二，前后端分别部署，静态资源放在前端服务器，业务代码放在后端服务器 前端服务器需要接收Http请求 前端服务器需要进行视图解析（可以使用vue.js、angular.js） 前端服务器需要处理路由（也就是页面之间的跳转逻辑） 后端服务器只需要返回数据]]></content>
      <categories>
        <category>9-网站架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>分离</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot添加自定义拦截器]]></title>
    <url>%2F2019%2F03%2F24%2Finterceptor%2F</url>
    <content type="text"><![CDATA[概述1.自定义拦截器的使用场景:处理所有请求的共性问题 解决权限验证问题 处理乱码问题 2.拦截器与过滤器的区别 拦截器Interceptor依赖于框架容器，基于反射机制，只过滤请求 过滤器Filter依赖于Servlet容器，基于回调函数，过滤范围大 使用方法1.自定义拦截器123456789101112131415161718192021222324252627282930313233343536@Componentpublic class TestInterceptor implements HandlerInterceptor &#123; /** * 返回值说明是否需要将当前的请求拦截下来 * false：请求将被终止 * true：请求会被继续运行 * Object handler 表示的是被拦截的请求的目标对象 */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println("TestInterceptor.preHandle()"); return true; &#125; /** * modelAndView： * 可以通过modelAndView参数改变显示的视图，或者修改发往视图的方法 */ @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println("TestInterceptor.postHandle()"); &#125; /** * 在视图加载完毕之后调用 * 常用于作于资源的销毁，流等 * 类似于析构函数 */ @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println("TestInterceptor.afterCompletion()"); &#125;&#125; 2.自定义MVC配置类12345678910@Componentpublic class WebMvcConfig extends WebMvcConfigurerAdapter &#123; @Resource private TestInterceptor testInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(testInterceptor); &#125;&#125;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>拦截器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库连接池的使用]]></title>
    <url>%2F2019%2F03%2F22%2Fdatasource%2F</url>
    <content type="text"><![CDATA[概述 数据库连接池，通常也称为数据源。负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。 常见的三种数据库连接池 DBCP：DBCP是一个依赖Jakarta commons-pool对象池机制的数据库连接池.DBCP可以直接的在应用程序中使用，Tomcat的数据源使用的就是DBCP。 c3p0：c3p0是一个开放源代码的JDBC连接池，它在lib目录中与Hibernate一起发布,包括了实现jdbc3和jdbc2扩展规范说明的Connection 和Statement 池的DataSources 对象。 Druid：阿里出品，淘宝和支付宝专用数据库连接池，但它不仅仅是一个数据库连接池，它还包含一个ProxyDriver，一系列内置的JDBC组件库，一个SQL Parser。支持所有JDBC兼容的数据库，包括Oracle、MySql、Derby、Postgresql、SQL Server、H2等等。 基本配置 DBCP c3p0 Druid 用户名 username user username 密码 password password password URL url jdbcUrl jdbcUrl 驱动类名 driverClassName driverClass driverClassName]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>连接池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue学习总结]]></title>
    <url>%2F2019%2F03%2F21%2Fvue%2F</url>
    <content type="text"><![CDATA[概述 Vue.js 是前端的主流框架之一，和Angular.js、React.js 一起，并成为前端三大主流框架。 Vue.js 是一套构建用户界面的框架，只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。 Vue.js 能够让我们不再操作DOM元素、提高渲染效率、进行双向数据绑定。 框架的发展历程： 原生JS -&gt; Jquery之类的类库 -&gt; 前端模板引擎 -&gt; Angular.js / Vue.js 框架和库的区别 框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。 库：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。 后端中的 MVC 与 前端中的 MVVM 之间的区别 MVC 是后端的分层开发概念； MVVM是前端视图层的概念，主要关注于 视图层分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View , VM(ViewModel) 基本结构123&lt;div id="app"&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;p&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var vm = new Vue(&#123; el: '#app', //等价于后面的 .$mount('#app') 用其中之一就可以了 render: h =&gt; h(App), //理解不够深入，参考（https://cn.vuejs.org/v2/api/?#render） data: &#123; //页面响应的数据都放在这里如上（组件只接受 function 且必须返回一个对象），zhicvm.$data 访问这里面的data msg: 'Welcome', &#125;, props:&#123; //props 可以是数组或对象，接收任何值 &#125;, methods: &#123; //页面或组件定义的方法的集合，可通过 vm.reset() 直接调用 reset: function()&#123; this.msg = '这是重新设置之后的数据' &#125; &#125;, computed: &#123; //计算属性(computed)与方法(methods) 类似，如果计算数据量比较大，建议放到这里 //计算属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。 //参考（https://cn.vuejs.org/v2/api/?#computed） &#125;, components：&#123; // 局部组件注册的地方 'component-a': ComponentA, 'component-b': ComponentB &#125;, directives: &#123; // 局部指令注册的地方 focus: &#123; // 指令的定义 inserted: function (el,binding) &#123; el.focus(); &#125; &#125; &#125;, filters:&#123; // 局部过滤器注册的地方 &#125;, //生命周期钩子 beforeCreate: function ()&#123;&#125;, //在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。 created: function ()&#123;&#125;,//在实例创建完成后被立即调用。 beforeMount: function ()&#123;&#125;,//在挂载开始之前被调用：相关的 render 函数首次被调用。 mounted: function ()&#123;&#125;,//el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。 beforeUpdate: function ()&#123;&#125;,//数据更新时调用，发生在虚拟 DOM 打补丁之前。 updated: function ()&#123;&#125;,//由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。 beforeDestroy: function ()&#123;&#125;,//实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed: function ()&#123; //Vue 实例销毁后调用。 //调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 &#125;,&#125;).$mount('#app') Vue指令 v-text: 输出文本 v-html: 输出html v-show: 控制元素是否显示 v-if: 条件渲染 v-for: 循环渲染DOM元素 v-model: 作用于、、,把这些标签的value值绑定到v-model的变量 v-pre: 跳过这个元素和它的子元素的编译过程 v-once: 只渲染元素和组件一次 v-on: 事件绑定 v-bind: 属性绑定 Vue组件组件是可复用的 Vue 实例，所以它们与 new Vue 接收相同的选项，例如 data、computed、watch、methods 以及生命周期钩子等。注意：组件没有 el 这样根实例特有的选项；而根实例没有 props 这个子组件特有的属性。 单文件组件1234567891011121314151617181920// .vue // 在单文件组件中 template 标签下只能有一个根元素&lt;template&gt; &lt;div class="home"&gt; &lt;p&gt;&#123;&#123;getting&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: "home", // 便于在vue-devtools 调试中提供更加友好的警告信息 data: function () &#123; return &#123; getting: 'welcome' &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;// 局部css样式&lt;/style&gt; 全局注册123// main.jsimport home from './components/home/home'Vue.component('home',home); 组件间传值通过 Prop 向子组件传递数据，这种传值方式是单向数据流。12345678910// HTML 中的特性名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。// 这意味着当你使用 DOM 中的模板时，驼峰命名法的 prop 名需要使用其等价的 短横线分隔命名命名。// 如果使用字符串模板，那么这个限制就不存在了。Vue.component(&apos;my-component&apos;, &#123; props: [&apos;myTitle&apos;], template: &apos;&lt;h3&gt;&#123;&#123; myTitle&#125;&#125;&lt;/h3&gt;&apos;&#125;)// HTML&lt;my-component my-title=&apos;hello world&apos;&gt;&lt;/my-component&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot学习总结]]></title>
    <url>%2F2019%2F03%2F20%2Fspringboot%2F</url>
    <content type="text"><![CDATA[概述Spring Boot即： 简化Spring应用开发的一个框架 整个Spring技术栈的一个大整合 J2EE开发的一站式解决方案 helloworld 使用idea的Spring Initializer快速创建Spring Boot项目 填写组织名和项目名 选择web应用 目录结构如下 默认生成的Spring Boot项目； 主程序已经生成好了，我们只需要我们自己的逻辑 resources文件夹中目录结构 static：保存所有的静态资源； js css images templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf） application.properties：Spring Boot应用的配置文件；可以修改一些默认设置 编写相关的Controller、Service，这里只编写一个HelloController 123456789@RestControllerpublic class HelloController &#123; @RequestMapping("/hello") public String hello() &#123; return "Hello World!"; &#125;&#125; 运行SpringbootApplication类 配置文件SpringBoot使用一个全局的配置文件，配置文件名是固定的； application.properties application.yml 配置文件的作用：修改SpringBoot自动配置的默认值 yml:12server: port: 8081 ​xml：123&lt;server&gt; &lt;port&gt;8081&lt;/port&gt;&lt;/server&gt; YAML语法基本语法k:(空格)v：表示一对键值对（空格必须有）； 以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的 12server: port: 8081 属性和值都是大小写敏感的 值的写法字面量：普通的值（数字，字符串，布尔） 字符串默认不用加上单引号或者双引号 双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思 单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据 对象、Map（属性和值）（键值对）：k: v：在下一行来写对象的属性和值的关系；注意缩进123friends: Name: zhangsan age: 20 行内写法：1friends: &#123;Name: zhangsan, age: 18&#125; 数组（List、Set）：用 - 值表示数组中的一个元素1234pets: - cat - dog - pig 行内写法1pets: [cat, dog, pig]]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>总结</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL使用总结]]></title>
    <url>%2F2019%2F03%2F20%2Fmysql%2F</url>
    <content type="text"><![CDATA[基本操作123456789/* Windows服务 */-- 启动MySQL net start mysql-- 创建Windows服务 sc create mysql binPath= mysqld_bin_path(注意：等号与值之间有空格)/* 连接与断开服务器 */mysql -h 地址 -P 端口 -u 用户名 -p 密码SHOW PROCESSLIST -- 显示哪些线程正在运行SHOW VARIABLES -- 显示系统变量信息 数据库操作12345678910111213141516171819/* 数据库操作 */ -------------------- 查看当前数据库 SELECT DATABASE();-- 显示当前时间、用户名、数据库版本 SELECT now(), user(), version();-- 创建库 CREATE DATABASE[ IF NOT EXISTS] 数据库名 数据库选项 数据库选项： CHARACTER SET charset_name COLLATE collation_name-- 查看已有库 SHOW DATABASES[ LIKE &apos;PATTERN&apos;]-- 查看当前库信息 SHOW CREATE DATABASE 数据库名-- 修改库的选项信息 ALTER DATABASE 库名 选项信息-- 删除库 DROP DATABASE[ IF EXISTS] 数据库名 同时删除该数据库相关的目录及其目录内容 表的操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576-- 创建表 CREATE [TEMPORARY] TABLE[ IF NOT EXISTS] [库名.]表名 ( 表的结构定义 )[ 表选项] 每个字段必须有数据类型 最后一个字段后不能有逗号 TEMPORARY 临时表，会话结束时表自动消失 对于字段的定义： 字段名 数据类型 [NOT NULL | NULL] [DEFAULT default_value] [AUTO_INCREMENT] [UNIQUE [KEY] | [PRIMARY] KEY] [COMMENT &apos;string&apos;]-- 表选项 -- 字符集 CHARSET = charset_name 如果表没有设定，则使用数据库字符集 -- 存储引擎 ENGINE = engine_name 表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同 常见的引擎：InnoDB MyISAM Memory/Heap BDB Merge Example CSV MaxDB Archive 不同的引擎在保存表的结构和数据时采用不同的方式 MyISAM表文件含义：.frm表定义，.MYD表数据，.MYI表索引 InnoDB表文件含义：.frm表定义，表空间数据和日志文件 SHOW ENGINES -- 显示存储引擎的状态信息 SHOW ENGINE 引擎名 &#123;LOGS|STATUS&#125; -- 显示存储引擎的日志或状态信息 -- 自增起始数 AUTO_INCREMENT = 行数 -- 数据文件目录 DATA DIRECTORY = &apos;目录&apos; -- 索引文件目录 INDEX DIRECTORY = &apos;目录&apos; -- 表注释 COMMENT = &apos;string&apos; -- 分区选项 PARTITION BY ... (详细见手册)-- 查看所有表 SHOW TABLES[ LIKE &apos;pattern&apos;] SHOW TABLES FROM 表名-- 查看表机构 SHOW CREATE TABLE 表名 （信息更详细） DESC 表名 / DESCRIBE 表名 / EXPLAIN 表名 / SHOW COLUMNS FROM 表名 [LIKE &apos;PATTERN&apos;] SHOW TABLE STATUS [FROM db_name] [LIKE &apos;pattern&apos;]-- 修改表 -- 修改表本身的选项 ALTER TABLE 表名 表的选项 eg: ALTER TABLE 表名 ENGINE=MYISAM; -- 对表进行重命名 RENAME TABLE 原表名 TO 新表名 RENAME TABLE 原表名 TO 库名.表名 （可将表移动到另一个数据库） -- RENAME可以交换两个表名 -- 修改表的字段机构（13.1.2. ALTER TABLE语法） ALTER TABLE 表名 操作名 -- 操作名 ADD[ COLUMN] 字段定义 -- 增加字段 AFTER 字段名 -- 表示增加在该字段名后面 FIRST -- 表示增加在第一个 ADD PRIMARY KEY(字段名) -- 创建主键 ADD UNIQUE [索引名] (字段名)-- 创建唯一索引 ADD INDEX [索引名] (字段名) -- 创建普通索引 DROP[ COLUMN] 字段名 -- 删除字段 MODIFY[ COLUMN] 字段名 字段属性 -- 支持对字段属性进行修改，不能修改字段名(所有原有属性也需写上) CHANGE[ COLUMN] 原字段名 新字段名 字段属性 -- 支持对字段名修改 DROP PRIMARY KEY -- 删除主键(删除主键前需删除其AUTO_INCREMENT属性) DROP INDEX 索引名 -- 删除索引 DROP FOREIGN KEY 外键 -- 删除外键-- 删除表 DROP TABLE[ IF EXISTS] 表名 ...-- 清空表数据 TRUNCATE [TABLE] 表名-- 复制表结构 CREATE TABLE 表名 LIKE 要复制的表名-- 复制表结构和数据 CREATE TABLE 表名 [AS] SELECT * FROM 要复制的表名-- 检查表是否有错误 CHECK TABLE tbl_name [, tbl_name] ... [option] ...-- 优化表 OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...-- 修复表 REPAIR [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... [QUICK] [EXTENDED] [USE_FRM]-- 分析表 ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... 数据操作1234567891011121314151617/* 数据操作 */ -------------------- 增 INSERT [INTO] 表名 [(字段列表)] VALUES (值列表)[, (值列表), ...] -- 如果要插入的值列表包含所有字段并且顺序一致，则可以省略字段列表。 -- 可同时插入多条数据记录！ REPLACE 与 INSERT 完全一样，可互换。 INSERT [INTO] 表名 SET 字段名=值[, 字段名=值, ...]-- 查 SELECT 字段列表 FROM 表名[ 其他子句] -- 可来自多个表的多个字段 -- 其他子句可以不使用 -- 字段列表可以用*代替，表示所有字段-- 删 DELETE FROM 表名[ 删除条件子句] 没有条件子句，则会删除全部-- 改 UPDATE 表名 SET 字段名=新值[, 字段名=新值] [更新条件] 字符集编码123456789101112131415161718/* 字符集编码 */ -------------------- MySQL、数据库、表、字段均可设置编码-- 数据编码与客户端编码不需一致SHOW VARIABLES LIKE &apos;character_set_%&apos; -- 查看所有字符集编码项 character_set_client 客户端向服务器发送数据时使用的编码 character_set_results 服务器端将结果返回给客户端所使用的编码 character_set_connection 连接层编码SET 变量名 = 变量值 SET character_set_client = gbk; SET character_set_results = gbk; SET character_set_connection = gbk;SET NAMES GBK; -- 相当于完成以上三个设置-- 校对集 校对集用以排序 SHOW CHARACTER SET [LIKE &apos;pattern&apos;]/SHOW CHARSET [LIKE &apos;pattern&apos;] 查看所有字符集 SHOW COLLATION [LIKE &apos;pattern&apos;] 查看所有校对集 CHARSET 字符集编码 设置字符集编码 COLLATE 校对集编码 设置校对集编码 数据类型(列类型)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697/* 数据类型（列类型） */ ------------------1. 数值类型-- a. 整型 ---------- 类型 字节 范围（有符号位） tinyint 1字节 -128 ~ 127 无符号位：0 ~ 255 smallint 2字节 -32768 ~ 32767 mediumint 3字节 -8388608 ~ 8388607 int 4字节 bigint 8字节 int(M) M表示总位数 - 默认存在符号位，unsigned 属性修改 - 显示宽度，如果某个数不够定义字段时设置的位数，则前面以0补填，zerofill 属性修改 例：int(5) 插入一个数&apos;123&apos;，补填后为&apos;00123&apos; - 在满足要求的情况下，越小越好。 - 1表示bool值真，0表示bool值假。MySQL没有布尔类型，通过整型0和1表示。常用tinyint(1)表示布尔型。-- b. 浮点型 ---------- 类型 字节 范围 float(单精度) 4字节 double(双精度) 8字节 浮点型既支持符号位 unsigned 属性，也支持显示宽度 zerofill 属性。 不同于整型，前后均会补填0. 定义浮点型时，需指定总位数和小数位数。 float(M, D) double(M, D) M表示总位数，D表示小数位数。 M和D的大小会决定浮点数的范围。不同于整型的固定范围。 M既表示总位数（不包括小数点和正负号），也表示显示宽度（所有显示符号均包括）。 支持科学计数法表示。 浮点数表示近似值。-- c. 定点数 ---------- decimal -- 可变长度 decimal(M, D) M也表示总位数，D表示小数位数。 保存一个精确的数值，不会发生数据的改变，不同于浮点数的四舍五入。 将浮点数转换为字符串来保存，每9位数字保存为4个字节。2. 字符串类型-- a. char, varchar ---------- char 定长字符串，速度快，但浪费空间 varchar 变长字符串，速度慢，但节省空间 M表示能存储的最大长度，此长度是字符数，非字节数。 不同的编码，所占用的空间不同。 char,最多255个字符，与编码无关。 varchar,最多65535字符，与编码有关。 一条有效记录最大不能超过65535个字节。 utf8 最大为21844个字符，gbk 最大为32766个字符，latin1 最大为65532个字符 varchar 是变长的，需要利用存储空间保存 varchar 的长度，如果数据小于255个字节，则采用一个字节来保存长度，反之需要两个字节来保存。 varchar 的最大有效长度由最大行大小和使用的字符集确定。 最大有效长度是65532字节，因为在varchar存字符串时，第一个字节是空的，不存在任何数据，然后还需两个字节来存放字符串的长度，所以有效长度是64432-1-2=65532字节。 例：若一个表定义为 CREATE TABLE tb(c1 int, c2 char(30), c3 varchar(N)) charset=utf8; 问N的最大值是多少？ 答：(65535-1-2-4-30*3)/3-- b. blob, text ---------- blob 二进制字符串（字节字符串） tinyblob, blob, mediumblob, longblob text 非二进制字符串（字符字符串） tinytext, text, mediumtext, longtext text 在定义时，不需要定义长度，也不会计算总长度。 text 类型在定义时，不可给default值-- c. binary, varbinary ---------- 类似于char和varchar，用于保存二进制字符串，也就是保存字节字符串而非字符字符串。 char, varchar, text 对应 binary, varbinary, blob.3. 日期时间类型 一般用整型保存时间戳，因为PHP可以很方便的将时间戳进行格式化。 datetime 8字节 日期及时间 1000-01-01 00:00:00 到 9999-12-31 23:59:59 date 3字节 日期 1000-01-01 到 9999-12-31 timestamp 4字节 时间戳 19700101000000 到 2038-01-19 03:14:07 time 3字节 时间 -838:59:59 到 838:59:59 year 1字节 年份 1901 - 2155datetime YYYY-MM-DD hh:mm:sstimestamp YY-MM-DD hh:mm:ss YYYYMMDDhhmmss YYMMDDhhmmss YYYYMMDDhhmmss YYMMDDhhmmssdate YYYY-MM-DD YY-MM-DD YYYYMMDD YYMMDD YYYYMMDD YYMMDDtime hh:mm:ss hhmmss hhmmssyear YYYY YY YYYY YY4. 枚举和集合-- 枚举(enum) ----------enum(val1, val2, val3...) 在已知的值中进行单选。最大数量为65535. 枚举值在保存时，以2个字节的整型(smallint)保存。每个枚举值，按保存的位置顺序，从1开始逐一递增。 表现为字符串类型，存储却是整型。 NULL值的索引是NULL。 空字符串错误值的索引值是0。-- 集合（set） ----------set(val1, val2, val3...) create table tab ( gender set(&apos;男&apos;, &apos;女&apos;, &apos;无&apos;) ); insert into tab values (&apos;男, 女&apos;); 最多可以有64个不同的成员。以bigint存储，共8个字节。采取位运算的形式。 当创建表时，SET成员值的尾部空格将自动被删除。 列属性(列约束)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* 列属性（列约束） */ ------------------1. PRIMARY 主键 - 能唯一标识记录的字段，可以作为主键。 - 一个表只能有一个主键。 - 主键具有唯一性。 - 声明字段时，用 primary key 标识。 也可以在字段列表之后声明 例：create table tab ( id int, stu varchar(10), primary key (id)); - 主键字段的值不能为null。 - 主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。 例：create table tab ( id int, stu varchar(10), age int, primary key (stu, age));2. UNIQUE 唯一索引（唯一约束） 使得某字段的值也不能重复。3. NULL 约束 null不是数据类型，是列的一个属性。 表示当前列是否可以为null，表示什么都没有。 null, 允许为空。默认。 not null, 不允许为空。 insert into tab values (null, &apos;val&apos;); -- 此时表示将第一个字段的值设为null, 取决于该字段是否允许为null4. DEFAULT 默认值属性 当前字段的默认值。 insert into tab values (default, &apos;val&apos;); -- 此时表示强制使用默认值。 create table tab ( add_time timestamp default current_timestamp ); -- 表示将当前时间的时间戳设为默认值。 current_date, current_time5. AUTO_INCREMENT 自动增长约束 自动增长必须为索引（主键或unique） 只能存在一个字段为自动增长。 默认为1开始自动增长。可以通过表属性 auto_increment = x进行设置，或 alter table tbl auto_increment = x;6. COMMENT 注释 例：create table tab ( id int ) comment &apos;注释内容&apos;;7. FOREIGN KEY 外键约束 用于限制主表与从表数据完整性。 alter table t1 add constraint `t1_t2_fk` foreign key (t1_id) references t2(id); -- 将表t1的t1_id外键关联到表t2的id字段。 -- 每个外键都有一个名字，可以通过 constraint 指定 存在外键的表，称之为从表（子表），外键指向的表，称之为主表（父表）。 作用：保持数据一致性，完整性，主要目的是控制存储在外键表（从表）中的数据。 MySQL中，可以对InnoDB引擎使用外键约束： 语法： foreign key (外键字段） references 主表名 (关联字段) [主表记录删除时的动作] [主表记录更新时的动作] 此时需要检测一个从表的外键需要约束为主表的已存在的值。外键在没有关联的情况下，可以设置为null.前提是该外键列，没有not null。 可以不指定主表记录更改或更新时的动作，那么此时主表的操作被拒绝。 如果指定了 on update 或 on delete：在删除或更新时，有如下几个操作可以选择： 1. cascade，级联操作。主表数据被更新（主键值更新），从表也被更新（外键值更新）。主表记录被删除，从表相关记录也被删除。 2. set null，设置为null。主表数据被更新（主键值更新），从表的外键被设置为null。主表记录被删除，从表相关记录外键被设置成null。但注意，要求该外键列，没有not null属性约束。 3. restrict，拒绝父表删除和更新。 注意，外键只被InnoDB存储引擎所支持。其他引擎是不支持的。 建表规范1234567891011121314/* 建表规范 */ ------------------ -- Normal Format, NF - 每个表保存一个实体信息 - 每个具有一个ID字段作为主键 - ID主键 + 原子表 -- 1NF, 第一范式 字段不能再分，就满足第一范式。 -- 2NF, 第二范式 满足第一范式的前提下，不能出现部分依赖。 消除符合主键就可以避免部分依赖。增加单列关键字。 -- 3NF, 第三范式 满足第二范式的前提下，不能出现传递依赖。 某个字段依赖于主键，而有其他字段依赖于该字段。这就是传递依赖。 将一个实体信息的数据放在一个表内实现。 SELECT123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/* SELECT */ ------------------SELECT [ALL|DISTINCT] select_expr FROM -&gt; WHERE -&gt; GROUP BY [合计函数] -&gt; HAVING -&gt; ORDER BY -&gt; LIMITa. select_expr -- 可以用 * 表示所有字段。 select * from tb; -- 可以使用表达式（计算公式、函数调用、字段也是个表达式） select stu, 29+25, now() from tb; -- 可以为每个列使用别名。适用于简化列标识，避免多个列标识符重复。 - 使用 as 关键字，也可省略 as. select stu+10 as add10 from tb;b. FROM 子句 用于标识查询来源。 -- 可以为表起别名。使用as关键字。 SELECT * FROM tb1 AS tt, tb2 AS bb; -- from子句后，可以同时出现多个表。 -- 多个表会横向叠加到一起，而数据会形成一个笛卡尔积。 SELECT * FROM tb1, tb2; -- 向优化符提示如何选择索引 USE INDEX、IGNORE INDEX、FORCE INDEX SELECT * FROM table1 USE INDEX (key1,key2) WHERE key1=1 AND key2=2 AND key3=3; SELECT * FROM table1 IGNORE INDEX (key3) WHERE key1=1 AND key2=2 AND key3=3;c. WHERE 子句 -- 从from获得的数据源中进行筛选。 -- 整型1表示真，0表示假。 -- 表达式由运算符和运算数组成。 -- 运算数：变量（字段）、值、函数返回值 -- 运算符： =, &lt;=&gt;, &lt;&gt;, !=, &lt;=, &lt;, &gt;=, &gt;, !, &amp;&amp;, ||, in (not) null, (not) like, (not) in, (not) between and, is (not), and, or, not, xor is/is not 加上ture/false/unknown，检验某个值的真假 &lt;=&gt;与&lt;&gt;功能相同，&lt;=&gt;可用于null比较d. GROUP BY 子句, 分组子句 GROUP BY 字段/别名 [排序方式] 分组后会进行排序。升序：ASC，降序：DESC 以下[合计函数]需配合 GROUP BY 使用： count 返回不同的非NULL值数目 count(*)、count(字段) sum 求和 max 求最大值 min 求最小值 avg 求平均值 group_concat 返回带有来自一个组的连接的非NULL值的字符串结果。组内字符串连接。e. HAVING 子句，条件子句 与 where 功能、用法相同，执行时机不同。 where 在开始时执行检测数据，对原数据进行过滤。 having 对筛选出的结果再次进行过滤。 having 字段必须是查询出来的，where 字段必须是数据表存在的。 where 不可以使用字段的别名，having 可以。因为执行WHERE代码时，可能尚未确定列值。 where 不可以使用合计函数。一般需用合计函数才会用 having SQL标准要求HAVING必须引用GROUP BY子句中的列或用于合计函数中的列。f. ORDER BY 子句，排序子句 order by 排序字段/别名 排序方式 [,排序字段/别名 排序方式]... 升序：ASC，降序：DESC 支持多个字段的排序。g. LIMIT 子句，限制结果数量子句 仅对处理好的结果进行数量限制。将处理好的结果的看作是一个集合，按照记录出现的顺序，索引从0开始。 limit 起始位置, 获取条数 省略第一个参数，表示从索引0开始。limit 获取条数h. DISTINCT, ALL 选项 distinct 去除重复记录 默认为 all, 全部记录 UNION12345678/* UNION */ ------------------ 将多个select查询的结果组合成一个结果集合。 SELECT ... UNION [ALL|DISTINCT] SELECT ... 默认 DISTINCT 方式，即所有返回的行都是唯一的 建议，对每个SELECT查询加上小括号包裹。 ORDER BY 排序时，需加上 LIMIT 进行结合。 需要各select查询的字段数量一样。 每个select查询的字段列表(数量、类型)应一致，因为结果中的字段名以第一条select语句为准。 子查询1234567891011121314151617181920212223242526272829/* 子查询 */ ------------------ - 子查询需用括号包裹。-- from型 from后要求是一个表，必须给子查询结果取个别名。 - 简化每个查询内的条件。 - from型需将结果生成一个临时表格，可用以原表的锁定的释放。 - 子查询返回一个表，表型子查询。 select * from (select * from tb where id&gt;0) as subfrom where id&gt;1;-- where型 - 子查询返回一个值，标量子查询。 - 不需要给子查询取别名。 - where子查询内的表，不能直接用以更新。 select * from tb where money = (select max(money) from tb); -- 列子查询 如果子查询结果返回的是一列。 使用 in 或 not in 完成查询 exists 和 not exists 条件 如果子查询返回数据，则返回1或0。常用于判断条件。 select column1 from t1 where exists (select * from t2); -- 行子查询 查询条件是一个行。 select * from t1 where (id, gender) in (select id, gender from t2); 行构造符：(col1, col2, ...) 或 ROW(col1, col2, ...) 行构造符通常用于与对能返回两个或两个以上列的子查询进行比较。 -- 特殊运算符 != all() 相当于 not in = some() 相当于 in。any 是 some 的别名 != some() 不等同于 not in，不等于其中某一个。 all, some 可以配合其他运算符一起使用。 连接查询(join)123456789101112131415161718192021222324/* 连接查询(join) */ ------------------ 将多个表的字段进行连接，可以指定连接条件。-- 内连接(inner join) - 默认就是内连接，可省略inner。 - 只有数据存在时才能发送连接。即连接结果不能出现空行。 on 表示连接条件。其条件表达式与where类似。也可以省略条件（表示条件永远为真） 也可用where表示连接条件。 还有 using, 但需字段名相同。 using(字段名) -- 交叉连接 cross join 即，没有条件的内连接。 select * from tb1 cross join tb2;-- 外连接(outer join) - 如果数据不存在，也会出现在连接结果中。 -- 左外连接 left join 如果数据不存在，左表记录会出现，而右表为null填充 -- 右外连接 right join 如果数据不存在，右表记录会出现，而左表为null填充-- 自然连接(natural join) 自动判断连接条件完成连接。 相当于省略了using，会自动查找相同字段名。 natural join natural left join natural right joinselect info.id, info.name, info.stu_num, extra_info.hobby, extra_info.sex from info, extra_info where info.stu_num = extra_info.stu_id; TRUNCATE123456789/* TRUNCATE */ ------------------TRUNCATE [TABLE] tbl_name清空数据删除重建表区别：1，truncate 是删除表再创建，delete 是逐条删除2，truncate 重置auto_increment的值。而delete不会3，truncate 不知道删除了几条，而delete知道。4，当被用于带分区的表时，truncate 会保留分区 备份与还原123456789101112131415161718192021/* 备份与还原 */ ------------------备份，将数据的结构与表内数据保存起来。利用 mysqldump 指令完成。-- 导出mysqldump [options] db_name [tables]mysqldump [options] ---database DB1 [DB2 DB3...]mysqldump [options] --all--database1. 导出一张表 mysqldump -u用户名 -p密码 库名 表名 &gt; 文件名(D:/a.sql)2. 导出多张表 mysqldump -u用户名 -p密码 库名 表1 表2 表3 &gt; 文件名(D:/a.sql)3. 导出所有表 mysqldump -u用户名 -p密码 库名 &gt; 文件名(D:/a.sql)4. 导出一个库 mysqldump -u用户名 -p密码 --lock-all-tables --database 库名 &gt; 文件名(D:/a.sql)可以-w携带WHERE条件-- 导入1. 在登录mysql的情况下： source 备份文件2. 在不登录的情况下 mysql -u用户名 -p密码 库名 &lt; 备份文件 视图1234567891011121314151617181920212223242526272829什么是视图： 视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。 视图具有表结构文件，但不存在数据文件。 对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。 视图是存储在数据库中的查询的sql语句，它主要出于两种原因：安全原因，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。-- 创建视图CREATE [OR REPLACE] [ALGORITHM = &#123;UNDEFINED | MERGE | TEMPTABLE&#125;] VIEW view_name [(column_list)] AS select_statement - 视图名必须唯一，同时不能与表重名。 - 视图可以使用select语句查询到的列名，也可以自己指定相应的列名。 - 可以指定视图执行的算法，通过ALGORITHM指定。 - column_list如果存在，则数目必须等于SELECT语句检索的列数-- 查看结构 SHOW CREATE VIEW view_name-- 删除视图 - 删除视图后，数据依然存在。 - 可同时删除多个视图。 DROP VIEW [IF EXISTS] view_name ...-- 修改视图结构 - 一般不修改视图，因为不是所有的更新视图都会映射到表上。 ALTER VIEW view_name [(column_list)] AS select_statement-- 视图作用 1. 简化业务逻辑 2. 对客户端隐藏真实的表结构-- 视图算法(ALGORITHM) MERGE 合并 将视图的查询语句，与外部查询需要先合并再执行！ TEMPTABLE 临时表 将视图执行完毕后，形成临时表，再做外层查询！ UNDEFINED 未定义(默认)，指的是MySQL自主去选择相应的算法。 事务(transaction)123456789101112131415161718192021222324252627282930313233343536373839404142434445事务是指逻辑上的一组操作，组成这组操作的各个单元，要不全成功要不全失败。 - 支持连续SQL的集体成功或集体撤销。 - 事务是数据库在数据晚自习方面的一个功能。 - 需要利用 InnoDB 或 BDB 存储引擎，对自动提交的特性支持完成。 - InnoDB被称为事务安全型引擎。-- 事务开启 START TRANSACTION; 或者 BEGIN; 开启事务后，所有被执行的SQL语句均被认作当前事务内的SQL语句。-- 事务提交 COMMIT;-- 事务回滚 ROLLBACK; 如果部分操作发生问题，映射到事务开启前。-- 事务的特性 1. 原子性（Atomicity） 事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 2. 一致性（Consistency） 事务前后数据的完整性必须保持一致。 - 事务开始和结束时，外部数据一致 - 在整个事务过程中，操作是连续的 3. 隔离性（Isolation） 多个用户并发访问数据库时，一个用户的事务不能被其它用户的事物所干扰，多个并发事务之间的数据要相互隔离。 4. 持久性（Durability） 一个事务一旦被提交，它对数据库中的数据改变就是永久性的。-- 事务的实现 1. 要求是事务支持的表类型 2. 执行一组相关的操作前开启事务 3. 整组操作完成后，都成功，则提交；如果存在失败，选择回滚，则会回到事务开始的备份点。-- 事务的原理 利用InnoDB的自动提交(autocommit)特性完成。 普通的MySQL执行语句后，当前的数据提交操作均可被其他客户端可见。 而事务是暂时关闭“自动提交”机制，需要commit提交持久化数据操作。-- 注意 1. 数据定义语言（DDL）语句不能被回滚，比如创建或取消数据库的语句，和创建、取消或更改表或存储的子程序的语句。 2. 事务不能被嵌套-- 保存点 SAVEPOINT 保存点名称 -- 设置一个事务保存点 ROLLBACK TO SAVEPOINT 保存点名称 -- 回滚到保存点 RELEASE SAVEPOINT 保存点名称 -- 删除保存点-- InnoDB自动提交特性设置 SET autocommit = 0|1; 0表示关闭自动提交，1表示开启自动提交。 - 如果关闭了，那普通操作的结果对其他客户端也不可见，需要commit提交后才能持久化数据操作。 - 也可以关闭自动提交来开启事务。但与START TRANSACTION不同的是， SET autocommit是永久改变服务器的设置，直到下次再次修改该设置。(针对当前连接) 而START TRANSACTION记录开启前的状态，而一旦事务提交或回滚后就需要再次开启事务。(针对当前事务) 锁表1234567/* 锁表 */表锁定只用于防止其它客户端进行不正当地读取和写入MyISAM 支持表锁，InnoDB 支持行锁-- 锁定 LOCK TABLES tbl_name [AS alias]-- 解锁 UNLOCK TABLES 触发器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* 触发器 */ ------------------ 触发程序是与表有关的命名数据库对象，当该表出现特定事件时，将激活该对象 监听：记录的增加、修改、删除。-- 创建触发器CREATE TRIGGER trigger_name trigger_time trigger_event ON tbl_name FOR EACH ROW trigger_stmt 参数： trigger_time是触发程序的动作时间。它可以是 before 或 after，以指明触发程序是在激活它的语句之前或之后触发。 trigger_event指明了激活触发程序的语句的类型 INSERT：将新行插入表时激活触发程序 UPDATE：更改某一行时激活触发程序 DELETE：从表中删除某一行时激活触发程序 tbl_name：监听的表，必须是永久性的表，不能将触发程序与TEMPORARY表或视图关联起来。 trigger_stmt：当触发程序激活时执行的语句。执行多个语句，可使用BEGIN...END复合语句结构-- 删除DROP TRIGGER [schema_name.]trigger_name可以使用old和new代替旧的和新的数据 更新操作，更新前是old，更新后是new. 删除操作，只有old. 增加操作，只有new.-- 注意 1. 对于具有相同触发程序动作时间和事件的给定表，不能有两个触发程序。-- 字符连接函数concat(str1,str2,...])concat_ws(separator,str1,str2,...)-- 分支语句if 条件 then 执行语句elseif 条件 then 执行语句else 执行语句end if;-- 修改最外层语句结束符delimiter 自定义结束符号 SQL语句自定义结束符号delimiter ; -- 修改回原来的分号-- 语句块包裹begin 语句块end-- 特殊的执行1. 只要添加记录，就会触发程序。2. Insert into on duplicate key update 语法会触发： 如果没有重复记录，会触发 before insert, after insert; 如果有重复记录并更新，会触发 before insert, before update, after update; 如果有重复记录但是没有发生更新，则触发 before insert, before update3. Replace 语法 如果有记录，则执行 before insert, before delete, after delete, after insert SQL编程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130/* SQL编程 */ --------------------// 局部变量 ------------ 变量声明 declare var_name[,...] type [default value] 这个语句被用来声明局部变量。要给变量提供一个默认值，请包含一个default子句。值可以被指定为一个表达式，不需要为一个常数。如果没有default子句，初始值为null。-- 赋值 使用 set 和 select into 语句为变量赋值。 - 注意：在函数内是可以使用全局变量（用户自定义的变量）--// 全局变量 ------------ 定义、赋值set 语句可以定义并为变量赋值。set @var = value;也可以使用select into语句为变量初始化并赋值。这样要求select语句只能返回一行，但是可以是多个字段，就意味着同时为多个变量进行赋值，变量的数量需要与查询的列数一致。还可以把赋值语句看作一个表达式，通过select执行完成。此时为了避免=被当作关系运算符看待，使用:=代替。（set语句可以使用= 和 :=）。select @var:=20;select @v1:=id, @v2=name from t1 limit 1;select * from tbl_name where @var:=30;select into 可以将表中查询获得的数据赋给变量。 -| select max(height) into @max_height from tb;-- 自定义变量名为了避免select语句中，用户自定义的变量与系统标识符（通常是字段名）冲突，用户自定义变量在变量名前使用@作为开始符号。@var=10; - 变量被定义后，在整个会话周期都有效（登录到退出）--// 控制结构 ------------ if语句if search_condition then statement_list [elseif search_condition then statement_list]...[else statement_list]end if;-- case语句CASE value WHEN [compare-value] THEN result[WHEN [compare-value] THEN result ...][ELSE result]END-- while循环[begin_label:] while search_condition do statement_listend while [end_label];- 如果需要在循环内提前终止 while循环，则需要使用标签；标签需要成对出现。 -- 退出循环 退出整个循环 leave 退出当前循环 iterate 通过退出的标签决定退出哪个循环--// 内置函数 ------------ 数值函数abs(x) -- 绝对值 abs(-10.9) = 10format(x, d) -- 格式化千分位数值 format(1234567.456, 2) = 1,234,567.46ceil(x) -- 向上取整 ceil(10.1) = 11floor(x) -- 向下取整 floor (10.1) = 10round(x) -- 四舍五入去整mod(m, n) -- m%n m mod n 求余 10%3=1pi() -- 获得圆周率pow(m, n) -- m^nsqrt(x) -- 算术平方根rand() -- 随机数truncate(x, d) -- 截取d位小数-- 时间日期函数now(), current_timestamp(); -- 当前日期时间current_date(); -- 当前日期current_time(); -- 当前时间date(&apos;yyyy-mm-dd hh:ii:ss&apos;); -- 获取日期部分time(&apos;yyyy-mm-dd hh:ii:ss&apos;); -- 获取时间部分date_format(&apos;yyyy-mm-dd hh:ii:ss&apos;, &apos;%d %y %a %d %m %b %j&apos;); -- 格式化时间unix_timestamp(); -- 获得unix时间戳from_unixtime(); -- 从时间戳获得时间-- 字符串函数length(string) -- string长度，字节char_length(string) -- string的字符个数substring(str, position [,length]) -- 从str的position开始,取length个字符replace(str ,search_str ,replace_str) -- 在str中用replace_str替换search_strinstr(string ,substring) -- 返回substring首次在string中出现的位置concat(string [,...]) -- 连接字串charset(str) -- 返回字串字符集lcase(string) -- 转换成小写left(string, length) -- 从string2中的左边起取length个字符load_file(file_name) -- 从文件读取内容locate(substring, string [,start_position]) -- 同instr,但可指定开始位置lpad(string, length, pad) -- 重复用pad加在string开头,直到字串长度为lengthltrim(string) -- 去除前端空格repeat(string, count) -- 重复count次rpad(string, length, pad) --在str后用pad补充,直到长度为lengthrtrim(string) -- 去除后端空格strcmp(string1 ,string2) -- 逐字符比较两字串大小-- 流程函数case when [condition] then result [when [condition] then result ...] [else result] end 多分支if(expr1,expr2,expr3) 双分支。-- 聚合函数count()sum();max();min();avg();group_concat()-- 其他常用函数md5();default();--// 存储函数，自定义函数 ------------ 新建 CREATE FUNCTION function_name (参数列表) RETURNS 返回值类型 函数体 - 函数名，应该合法的标识符，并且不应该与已有的关键字冲突。 - 一个函数应该属于某个数据库，可以使用db_name.funciton_name的形式执行当前函数所属数据库，否则为当前数据库。 - 参数部分，由&quot;参数名&quot;和&quot;参数类型&quot;组成。多个参数用逗号隔开。 - 函数体由多条可用的mysql语句，流程控制，变量声明等语句构成。 - 多条语句应该使用 begin...end 语句块包含。 - 一定要有 return 返回值语句。-- 删除 DROP FUNCTION [IF EXISTS] function_name;-- 查看 SHOW FUNCTION STATUS LIKE &apos;partten&apos; SHOW CREATE FUNCTION function_name;-- 修改 ALTER FUNCTION function_name 函数选项--// 存储过程，自定义功能 ------------ 定义存储存储过程 是一段代码（过程），存储在数据库中的sql组成。一个存储过程通常用于完成一段业务逻辑，例如报名，交班费，订单入库等。而一个函数通常专注与某个功能，视为其他程序服务的，需要在其他语句中调用函数才可以，而存储过程不能被其他调用，是自己执行 通过call执行。-- 创建CREATE PROCEDURE sp_name (参数列表) 过程体参数列表：不同于函数的参数列表，需要指明参数类型IN，表示输入型OUT，表示输出型INOUT，表示混合型注意，没有返回值。 存储过程12345678910111213141516/* 存储过程 */ ------------------存储过程是一段可执行性代码的集合。相比函数，更偏向于业务逻辑。调用：CALL 过程名-- 注意- 没有返回值。- 只能单独调用，不可夹杂在其他语句中-- 参数IN|OUT|INOUT 参数名 数据类型IN 输入：在调用过程中，将数据输入到过程体内部的参数OUT 输出：在调用过程中，将过程体处理完的结果返回到客户端INOUT 输入输出：既可输入，也可输出-- 语法CREATE PROCEDURE 过程名 (参数列表)BEGIN 过程体END 用户和权限管理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/* 用户和权限管理 */ -------------------- root密码重置1. 停止MySQL服务2. [Linux] /usr/local/mysql/bin/safe_mysqld --skip-grant-tables &amp; [Windows] mysqld --skip-grant-tables3. use mysql;4. UPDATE `user` SET PASSWORD=PASSWORD(&quot;密码&quot;) WHERE `user` = &quot;root&quot;;5. FLUSH PRIVILEGES;用户信息表：mysql.user-- 刷新权限FLUSH PRIVILEGES;-- 增加用户CREATE USER 用户名 IDENTIFIED BY [PASSWORD] 密码(字符串) - 必须拥有mysql数据库的全局CREATE USER权限，或拥有INSERT权限。 - 只能创建用户，不能赋予权限。 - 用户名，注意引号：如 &apos;user_name&apos;@&apos;192.168.1.1&apos; - 密码也需引号，纯数字密码也要加引号 - 要在纯文本中指定密码，需忽略PASSWORD关键词。要把密码指定为由PASSWORD()函数返回的混编值，需包含关键字PASSWORD-- 重命名用户RENAME USER old_user TO new_user-- 设置密码SET PASSWORD = PASSWORD(&apos;密码&apos;) -- 为当前用户设置密码SET PASSWORD FOR 用户名 = PASSWORD(&apos;密码&apos;) -- 为指定用户设置密码-- 删除用户DROP USER 用户名-- 分配权限/添加用户GRANT 权限列表 ON 表名 TO 用户名 [IDENTIFIED BY [PASSWORD] &apos;password&apos;] - all privileges 表示所有权限 - *.* 表示所有库的所有表 - 库名.表名 表示某库下面的某表 GRANT ALL PRIVILEGES ON `pms`.* TO &apos;pms&apos;@&apos;%&apos; IDENTIFIED BY &apos;pms0817&apos;;-- 查看权限SHOW GRANTS FOR 用户名 -- 查看当前用户权限 SHOW GRANTS; 或 SHOW GRANTS FOR CURRENT_USER; 或 SHOW GRANTS FOR CURRENT_USER();-- 撤消权限REVOKE 权限列表 ON 表名 FROM 用户名REVOKE ALL PRIVILEGES, GRANT OPTION FROM 用户名 -- 撤销所有权限-- 权限层级-- 要使用GRANT或REVOKE，您必须拥有GRANT OPTION权限，并且您必须用于您正在授予或撤销的权限。全局层级：全局权限适用于一个给定服务器中的所有数据库，mysql.user GRANT ALL ON *.*和 REVOKE ALL ON *.*只授予和撤销全局权限。数据库层级：数据库权限适用于一个给定数据库中的所有目标，mysql.db, mysql.host GRANT ALL ON db_name.*和REVOKE ALL ON db_name.*只授予和撤销数据库权限。表层级：表权限适用于一个给定表中的所有列，mysql.talbes_priv GRANT ALL ON db_name.tbl_name和REVOKE ALL ON db_name.tbl_name只授予和撤销表权限。列层级：列权限适用于一个给定表中的单一列，mysql.columns_priv 当使用REVOKE时，您必须指定与被授权列相同的列。-- 权限列表ALL [PRIVILEGES] -- 设置除GRANT OPTION之外的所有简单权限ALTER -- 允许使用ALTER TABLEALTER ROUTINE -- 更改或取消已存储的子程序CREATE -- 允许使用CREATE TABLECREATE ROUTINE -- 创建已存储的子程序CREATE TEMPORARY TABLES -- 允许使用CREATE TEMPORARY TABLECREATE USER -- 允许使用CREATE USER, DROP USER, RENAME USER和REVOKE ALL PRIVILEGES。CREATE VIEW -- 允许使用CREATE VIEWDELETE -- 允许使用DELETEDROP -- 允许使用DROP TABLEEXECUTE -- 允许用户运行已存储的子程序FILE -- 允许使用SELECT...INTO OUTFILE和LOAD DATA INFILEINDEX -- 允许使用CREATE INDEX和DROP INDEXINSERT -- 允许使用INSERTLOCK TABLES -- 允许对您拥有SELECT权限的表使用LOCK TABLESPROCESS -- 允许使用SHOW FULL PROCESSLISTREFERENCES -- 未被实施RELOAD -- 允许使用FLUSHREPLICATION CLIENT -- 允许用户询问从属服务器或主服务器的地址REPLICATION SLAVE -- 用于复制型从属服务器（从主服务器中读取二进制日志事件）SELECT -- 允许使用SELECTSHOW DATABASES -- 显示所有数据库SHOW VIEW -- 允许使用SHOW CREATE VIEWSHUTDOWN -- 允许使用mysqladmin shutdownSUPER -- 允许使用CHANGE MASTER, KILL, PURGE MASTER LOGS和SET GLOBAL语句，mysqladmin debug命令；允许您连接（一次），即使已达到max_connections。UPDATE -- 允许使用UPDATEUSAGE -- “无权限”的同义词GRANT OPTION -- 允许授予权限 表维护12345678/* 表维护 */-- 分析和存储表的关键字分布ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE 表名 ...-- 检查一个或多个表是否有错误CHECK TABLE tbl_name [, tbl_name] ... [option] ...option = &#123;QUICK | FAST | MEDIUM | EXTENDED | CHANGED&#125;-- 整理数据文件的碎片OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... 杂项1234567891011121314/* 杂项 */ ------------------1. 可用反引号（`）为标识符（库名、表名、字段名、索引、别名）包裹，以避免与关键字重名！中文也可以作为标识符！2. 每个库目录存在一个保存当前数据库的选项文件db.opt。3. 注释： 单行注释 # 注释内容 多行注释 /* 注释内容 */ 单行注释 -- 注释内容 (标准SQL注释风格，要求双破折号后加一空格符（空格、TAB、换行等）)4. 模式通配符： _ 任意单个字符 % 任意多个字符，甚至包括零字符 单引号需要进行转义 \&apos;5. CMD命令行内的语句结束符可以为 &quot;;&quot;, &quot;\G&quot;, &quot;\g&quot;，仅影响显示结果。其他地方还是用分号结束。delimiter 可修改当前对话的语句结束符。6. SQL对大小写不敏感7. 清除已有语句：\c]]></content>
      <categories>
        <category>5-数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[example类]]></title>
    <url>%2F2019%2F03%2F17%2Fexample%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[概述在使用mybatis逆向工程后，生成的pojo类中，有一部分是名字为XxxExample的类出现。这个类是专门用来对这个单表进行查询的类，对该单表的CURD操作是脱离sql性质的(已经通过逆向工程生成相应的sql)，直接在service层就可以完成相应操作。Example类有三个成员变量： distinct字段用于指定DISTINCT查询。 orderByClause字段用于指定ORDER BY条件,这个条件没有构造方法,直接通过传递字符串值指定。 oredCriteria字段用于自定义查询条件。 它还包含一个static的内部类 Criteria ，在Criteria中有很多方法，主要是定义SQL语句where后的查询条件。 Example类可以用来生成一个几乎无限的where子句。 创建 Criteria 对象 可以使用Example类中or()。 用法12TestTableExample example = new TestTableExample();example.or().andField1EqualTo(5); 动态生成的where子句是:where field1 = 5]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
        <tag>逆向工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis逆向工程总结]]></title>
    <url>%2F2019%2F03%2F16%2Fmybatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[概述 mybatis逆向工程可以针对单表自动生成mybatis执行所需要的代码（pojo、mapper.java、mapper.xml）。 实际开发中，常用的逆向工程方式：由数据库的表生成java代码。 使用方法1.在pom.xml文件中添加以下依赖12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.5&lt;/version&gt;&lt;/dependency&gt; 2.建立配置文件generatorConfig.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt; &lt;generatorConfiguration&gt; &lt;context id="DB2Tables" targetRuntime="MyBatis3"&gt; &lt;commentGenerator&gt; &lt;!-- 是否去除自动生成的注释 --&gt; &lt;property name="suppressAllComments" value="true"/&gt; &lt;/commentGenerator&gt; &lt;!-- Mysql数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt; &lt;jdbcConnection driverClass="com.mysql.jdbc.Driver" connectionURL="jdbc:mysql://localhost:3306/e3mall" userId="root" password="111"&gt; &lt;/jdbcConnection&gt; &lt;!-- Oracle数据库 &lt;jdbcConnection driverClass="oracle.jdbc.OracleDriver" connectionURL="jdbc:oracle:thin:@127.0.0.1:1521:yycg" userId="yycg" password="yycg"&gt; &lt;/jdbcConnection&gt; --&gt; &lt;!-- 默认为false，把JDBC DECIMAL 和NUMERIC类型解析为Integer，为true时 把JDBC DECIMAL 和NUMERIC类型解析为java.math.BigDecimal --&gt; &lt;javaTypeResolver &gt; &lt;property name="forceBigDecimals" value="false" /&gt; &lt;/javaTypeResolver&gt; &lt;!-- targetProject：生成POJO类的位置 --&gt; &lt;javaModelGenerator targetPackage="cn.e3mall.pojo" targetProject=".\src"&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name="enableSubPackages" value="false" /&gt; &lt;!-- 从数据库返回的值被清理前后的空格 --&gt; &lt;property name="trimStrings" value="true" /&gt; &lt;/javaModelGenerator&gt; &lt;!-- targetProject：mapper映射文件生成的位置 --&gt; &lt;sqlMapGenerator targetPackage="cn.e3mall.mapper" targetProject=".\src"&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name="enableSubPackages" value="false" /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- targetProject：mapper接口生成的的位置 --&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="cn.e3mall.mapper" targetProject=".\src"&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name="enableSubPackages" value="false" /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 指定数据表 --&gt; &lt;table schema="" tableName="tb_content"&gt;&lt;/table&gt; &lt;table schema="" tableName="tb_content_category"&gt;&lt;/table&gt; &lt;table schema="" tableName="tb_item"&gt;&lt;/table&gt; &lt;table schema="" tableName="tb_item_cat"&gt;&lt;/table&gt; &lt;table schema="" tableName="tb_item_desc"&gt;&lt;/table&gt; &lt;table schema="" tableName="tb_item_param"&gt;&lt;/table&gt; &lt;table schema="" tableName="tb_item_param_item"&gt;&lt;/table&gt; &lt;table schema="" tableName="tb_order"&gt;&lt;/table&gt; &lt;table schema="" tableName="tb_order_item"&gt;&lt;/table&gt; &lt;table schema="" tableName="tb_order_shipping"&gt;&lt;/table&gt; &lt;table schema="" tableName="tb_user"&gt;&lt;/table&gt; &lt;!-- 有些表的字段需要指定java类型 &lt;table schema="DB2ADMIN" tableName="ALLTYPES" domainObjectName="Customer" &gt; &lt;property name="useActualColumnNames" value="true"/&gt; &lt;generatedKey column="ID" sqlStatement="DB2" identity="true" /&gt; &lt;columnOverride column="DATE_FIELD" property="startDate" /&gt; &lt;ignoreColumn column="FRED" /&gt; &lt;columnOverride column="LONG_VARCHAR_FIELD" jdbcType="VARCHAR" /&gt; &lt;/table&gt; --&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 3.建立生成程序GeneratorSqlmap.java123456789101112131415161718192021222324package top.ysccx.tmall.generator;import java.io.InputStream;import java.util.*;import org.mybatis.generator.api.MyBatisGenerator;import org.mybatis.generator.config.Configuration;import org.mybatis.generator.config.xml.ConfigurationParser;import org.mybatis.generator.internal.DefaultShellCallback;public class GeneratorSqlmap &#123; public static void main(String[] args) throws Exception&#123; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; // 指定配置文件 InputStream is = Generator.class.getClassLoader().getResource("generatorConfig.xml").openStream(); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(is); is.close(); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); &#125;&#125; 4.运行GeneratorSqlmap.java 注意事项mapper.xml文件已存在时，如果进行重新生成则mapper.xml文件内容不被覆盖而是进行内容增加，结果会导致mybatis解析失败。解决办法：删除原来的已经生成的mapper.xml文件重新生成。mybais自动生成的pojo以及mapper.java文件不是内容追加而是直接覆盖没有问题。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
        <tag>Java</tag>
        <tag>逆向工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络基础]]></title>
    <url>%2F2019%2F03%2F13%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[OSI，TCP/IP，五层协议的体系结构 每一层的作用 物理层：通过媒介传输比特,确定机械及电气规范（比特Bit） 数据链路层：将比特组装成帧和点到点的传递（帧Frame） 网络层：负责数据包从源到宿的传递和网际互连（包Packet） 传输层：提供端到端的可靠报文传递和错误恢复（段Segment） 会话层：建立、管理和终止会话（会话协议数据单元SPDU） 表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU） 应用层：允许访问OSI环境的手段（应用协议数据单元APDU） 每一层的协议 物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器） 数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机） 网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器） 传输层：TCP、UDP、SPX 会话层：NFS、SQL、NETBIOS、RPC 表示层：JPEG、MPEG、ASII 应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS TCP对应的应用层协议 FTP：定义了文件传输协议，使用21端口。常说某某计算机开了FTP服务便是启动了文件传输服务。下载文件，上传主页，都要用到FTP服务。 Telnet：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务。如以前的BBS是-纯字符界面的，支持BBS的服务器将23端口打开，对外提供服务。 SMTP：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么SMTP端口设置这个栏，服务器开放的是25号端口。 POP3：它是和SMTP对应，POP3用于接收邮件。通常情况下，POP3协议所用的是110端口。也是说，只要你有相应的使用POP3协议的程序（例如Fo-xmail或Outlook），就可以不以Web方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163邮箱就没有必要先进入网易网站，再进入自己的邮-箱来收信）。 HTTP：从Web服务器传输超文本到本地浏览器的传送协议。 UDP对应的应用层协议 DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。 SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。 TFTP(Trival File Transfer Protocal)：简单文件传输协议，该协议在熟知端口69上使用UDP服务。 IP地址的分类 ARP协议ARP地址解析协议，简单说就是，在IP以太网中，当一个上层协议要发包时，有了该节点的IP地址，ARP就能提供该节点的MAC地址。它的工作原理如下： 首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。 当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机IP地址，源主机MAC地址，目的主机的IP地址。 当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。 源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。 如果目标IP与自己不在同一个网段，这种情况需要将包发给默认网关，所以主要获取网关的MAC地址。如果arp高速缓存有默认网关的MAC地址，直接发送IP数据报道默认网关，再由网关转发到外网；如果arp高速缓存没有默认网关的MAC地址，还是发送ARP广播请求默认网关的MAC地址，缓存该地址，并且发送数据报到网关。 HTTP协议HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。HTTP协议的主要特点可概括如下： 支持客户/服务器模式。 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 TCP三次握手和四次挥手三次握手：(我要和你建立链接，你真的要和我建立链接么，我真的要和你建立链接，成功) 第一次握手：客户端发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认； 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。 四次挥手：(我要和你断开链接；好的，断吧。我也要和你断开链接；好的，断吧)： 第一次挥手：客户端主动关闭方发送一个FIN，用来关闭客户端到服务端的数据传送，也就是客户端告诉服务端：我已经不会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，客户端依然会重发这些数据)，但是，此时客户端还可以接受数据。 第二次挥手：服务端收到FIN包后，发送一个ACK给客户端，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。 第三次挥手：服务端发送一个FIN，用来关闭服务端到客户端的数据传送，也就是告诉客户端，我的数据也发送完了，不会再给你发数据了。 第四次挥手：客户端收到FIN后，发送一个ACK给服务端，确认序号为收到序号+1，至此，完成四次挥手。 为什么TCP链接需要三次握手，两次不可以么，为什么？为了防止已失效的链接请求报文突然又传送到了服务端，因而产生错误。客户端发出的连接请求报文并未丢失，而是在某个网络节点长时间滞留了，以致延误到链接释放以后的某个时间才到达Server。这是，Server误以为这是Client发出的一个新的链接请求，于是就向客户端发送确认数据包，同意建立链接。若不采用“三次握手”，那么只要Server发出确认数据包，新的链接就建立了。由于client此时并未发出建立链接的请求，所以其不会理睬Server的确认，也不与Server通信；而这时Server一直在等待Client的请求，这样Server就白白浪费了一定的资源。若采用“三次握手”，在这种情况下，由于Server端没有收到来自客户端的确认，则就会知道Client并没有要求建立请求，就不会建立链接。 为什么连接的时候是三次握手，关闭的时候却是四次握手?TCP是全双工模式，关闭连接时，当主机B收到主机A的FIN报文时，仅仅表示主机 A不再发送数据了但是还能接收数据。此时，主机B也未必全部数据都发送给A了，所以B可以立即close；也可以发送一些数据给A后，再发送FIN报文给对方来表示同意现在关闭连接，因此，主机BACK和FIN一般都会分开发送。 TCP协议如何来保证传输的可靠性TCP提供一种面向连接的、可靠的字节流服务。其中，面向连接意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个TCP连接。在一个TCP连接中，仅有两方进行彼此通信；而字节流服务意味着两个应用程序通过TCP链接交换8bit字节构成的字节流，TCP不在字节流中插入记录标识符。对于可靠性，TCP通过以下方式进行保证： 数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据； 对失序数据包重排序：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层； 丢弃重复数据：对于重复数据，能够丢弃重复数据； 应答机制：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒； 超时重发：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段； 流量控制：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。 从输入网址到获得页面的过程 浏览器查询 DNS，获取域名对应的IP地址:具体过程包括浏览器搜索自身的DNS缓存、搜索操作系统的DNS缓存、读取本地的Host文件和向本地DNS服务器进行查询等。对于向本地DNS服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；如果要查询的域名不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询； 浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立链接，发起三次握手； TCP/IP链接建立起来后，浏览器向服务器发送HTTP请求； 服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器； 浏览器解析并渲染视图，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源； 浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。 socketsocket是通信的基石。支持TCP/IP等协议的基本操作单元。应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。]]></content>
      <categories>
        <category>1-基础</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hashCode与equals]]></title>
    <url>%2F2019%2F03%2F13%2FhashCode%E4%B8%8Eequals%2F</url>
    <content type="text"><![CDATA[hashCode介绍hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。哈希表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。 为什么要有hashCode？为了提高程序的效率才实现了hashcode方法，先进行hashcode的比较，如果不同，那没就不必在进行equals的比较了，这样就大大减少了equals比较的次数，这对比需要比较的数量很大的效率提高是很明显的。 为什么重写equals时必须重写hashCode方法？首先equals与hashcode之间有这样的规定： 如果两个对象相同（即用equals比较返回true），那么它们的hashCode值一定要相同。 如果两个对象的hashCode相同，它们并不一定相同。 其实简单的说就是为了保证在equals相同的情况下hashcode值必定相同。如果重写了equals而未重写hashcode方法，就有可能会出现两个对象equals相同，但hashcode却不相同的情况，这样就违反了第一条规定。]]></content>
      <categories>
        <category>1-基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[==与equals]]></title>
    <url>%2F2019%2F03%2F13%2F%E4%B8%8Eequals%2F</url>
    <content type="text"><![CDATA[== : 它是用来比较两个变量的值是否相等，也就是用于比较变量所存储的数值是否相同。(基本数据类型==比较的是值，引用数据类型==比较的是变量中存的内存地址) equals() : 它的作用也是判断两个对象的内容是否相同。但它一般有两种使用情况： 类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。 类覆盖了equals()方法。一般，我们都覆盖equals()方法来两个对象的内容相等；若它们的内容相等，则返回true。 例如，对于下面的代码：12String a=new String("ysc");String b=new String("ysc"); 两条new语句创建了两个对象，然后用a,b这两个变量分别指向了其中一个对象，这是两个不同的对象，它们的首地址是不同的，即a和b中存储的数值是不相同的，所以，表达式a==b将返回false。而这两个对象中的内容是相同的，所以，表达式a.equals(b)将返回true。 说明：String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。 Object类的equals方法的实现代码如下：123boolean equals(Object o)&#123;return this==o;&#125;]]></content>
      <categories>
        <category>1-基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tomcat两种部署方式的区别]]></title>
    <url>%2F2019%2F03%2F09%2Fwar%2F</url>
    <content type="text"><![CDATA[在用idea部署Javaweb项目的时候，经常看到这种情况这里有两种部署方式，它们的区别如下： war： 这种模式是先打成war包，再发布，正常的发布就是用的这种。 工程target目录下会生成war包, 并且解压后的war包会被部署到tomcat的webapp 目录下。 注意：如果application-context 设置为 /， tomcat目录下不会有解压后的war文件，只有指定文件目录，才会生成文件夹，这个文件夹作为项目的根目录 war exploded ：这种模式是直接把文件夹、jsp页面 、classes等等移到Tomcat 部署文件夹里面，进行加载部署。因此这种方式支持热部署，一般在开发的时候也是用这种方式。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
        <tag>war</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssm框架整合]]></title>
    <url>%2F2019%2F03%2F08%2Fssm%2F</url>
    <content type="text"><![CDATA[概述SpringSpring就像是整个项目中装配bean的大工厂，在配置文件中可以指定使用特定的参数去调用实体类的构造方法来实例化对象。Spring的核心思想是IoC（控制反转），即不再需要程序员去显式地new一个对象，而是让Spring框架帮你来完成这一切。 SpringMVCSpringMVC在项目中拦截用户请求，它的核心Servlet即DispatcherServlet承担中介或是前台这样的职责，将用户请求通过HandlerMapping去匹配Controller，Controller就是具体对应请求所执行的操作。 MyBatismybatis是对jdbc的封装，它让数据库底层操作变的透明。mybatis的操作都是围绕一个sqlSessionFactory实例展开的。mybatis通过配置文件关联到各实体类的Mapper文件，Mapper文件中配置了每个类对数据库所需进行的sql语句映射。在每次与数据库交互时，通过sqlSessionFactory拿到一个sqlSession，再执行sql命令。 整体架构图 项目结构 核心步骤在pom.xml文件中声明依赖123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;ssm&lt;/name&gt; &lt;groupId&gt;top.ysccx.ssm&lt;/groupId&gt; &lt;artifactId&gt;ssm&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt; &lt;artifactId&gt;maven-jetty-plugin&lt;/artifactId&gt; &lt;version&gt;6.1.7&lt;/version&gt; &lt;configuration&gt; &lt;connectors&gt; &lt;connector implementation="org.mortbay.jetty.nio.SelectChannelConnector"&gt; &lt;port&gt;8888&lt;/port&gt; &lt;maxIdleTime&gt;30000&lt;/maxIdleTime&gt; &lt;/connector&gt; &lt;/connectors&gt; &lt;webAppSourceDirectory&gt;$&#123;project.build.directory&#125;/$&#123;pom.artifactId&#125;-$&#123;pom.version&#125;&lt;/webAppSourceDirectory&gt; &lt;contextPath&gt;/&lt;/contextPath&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;properties&gt; &lt;!-- 设置项目编码编码 --&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;!-- spring版本号 --&gt; &lt;spring.version&gt;4.3.5.RELEASE&lt;/spring.version&gt; &lt;!-- mybatis版本号 --&gt; &lt;mybatis.version&gt;3.4.1&lt;/mybatis.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- java ee --&gt; &lt;dependency&gt; &lt;groupId&gt;javax&lt;/groupId&gt; &lt;artifactId&gt;javaee-api&lt;/artifactId&gt; &lt;version&gt;7.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 实现slf4j接口并整合 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JSON --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.8.7&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.41&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MyBatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis/spring整合包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--dependency&gt; &lt;groupId&gt;top.ysccx.ssm&lt;/groupId&gt; &lt;artifactId&gt;[the artifact id of the block to be mounted]&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency--&gt; &lt;/dependencies&gt;&lt;/project&gt; 在web.xml中声明编码过滤器并配置 DispatcherServlet123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt; &lt;!-- 编码过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 配置DispatcherServlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置springMVC需要加载的配置文件--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-*.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;!-- 匹配所有请求 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 在spring-mvc.xml中完成 Spring MVC 的相关配置1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd"&gt; &lt;!-- 扫描web相关的bean --&gt; &lt;context:component-scan base-package="top.ysccx.ssm.controller"/&gt; &lt;!-- 开启SpringMVC注解模式 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 静态资源默认servlet配置 --&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 配置jsp 显示ViewResolver --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/&gt; &lt;property name="prefix" value="/WEB-INF/views/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt;&lt;/beans&gt; 在spring-mybatis.xml中完成 spring 和 mybatis 的核心配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!-- 扫描service包下所有使用注解的类型 --&gt; &lt;context:component-scan base-package="top.ysccx.ssm.service"/&gt; &lt;!-- 配置数据库相关参数properties的属性：$&#123;url&#125; --&gt; &lt;context:property-placeholder location="classpath:jdbc.properties"/&gt; &lt;!-- 数据库连接池 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="user" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;property name="maxPoolSize" value="$&#123;c3p0.maxPoolSize&#125;"/&gt; &lt;property name="minPoolSize" value="$&#123;c3p0.minPoolSize&#125;"/&gt; &lt;property name="autoCommitOnClose" value="$&#123;c3p0.autoCommitOnClose&#125;"/&gt; &lt;property name="checkoutTimeout" value="$&#123;c3p0.checkoutTimeout&#125;"/&gt; &lt;property name="acquireRetryAttempts" value="$&#123;c3p0.acquireRetryAttempts&#125;"/&gt; &lt;/bean&gt; &lt;!-- 配置SqlSessionFactory对象 --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;!-- 扫描entity包 使用别名 --&gt; &lt;property name="typeAliasesPackage" value="top.ysccx.ssm.entity"/&gt; &lt;!-- 扫描sql配置文件:mapper需要的xml文件 --&gt; &lt;property name="mapperLocations" value="classpath:mapper/*.xml"/&gt; &lt;/bean&gt; &lt;!-- 配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!-- 注入sqlSessionFactory --&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"/&gt; &lt;!-- 给出需要扫描Dao接口包 --&gt; &lt;property name="basePackage" value="top.ysccx.ssm.dao"/&gt; &lt;/bean&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;!-- 配置基于注解的声明式事务 --&gt; &lt;tx:annotation-driven transaction-manager="transactionManager"/&gt;&lt;/beans&gt; 在jdbc.properties中配置 c3p0 数据库连接池1234567891011121314151617jdbc.driver=com.mysql.jdbc.Driver#数据库地址jdbc.url=jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf8#用户名jdbc.username=root#密码jdbc.password=admin#最大连接数c3p0.maxPoolSize=30#最小连接数c3p0.minPoolSize=10#关闭连接后不自动commitc3p0.autoCommitOnClose=false#获取连接超时时间c3p0.checkoutTimeout=10000#当获取连接失败重试次数c3p0.acquireRetryAttempts=2 在entity包下编写实体类User.java12345678910111213141516171819202122package top.ysccx.ssm.entity;public class User &#123; private int id; private String name; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 这个类用于建立相应数据库的ORM 在dao包下建立数据访问接口UserDao.java1234567package top.ysccx.ssm.dao;import top.ysccx.ssm.entity.User;public interface UserDao &#123; User findUserById(int id);&#125; 在resources/mapper下编写SQL映射文件UserDao.xml1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- 设置为UserDao接口方法提供sql语句配置 --&gt;&lt;mapper namespace="top.ysccx.ssm.dao.UserDao"&gt; &lt;select id="findUserById" resultType="top.ysccx.ssm.entity.User" parameterType="int"&gt; SELECT * FROM user WHERE id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 说明：在mybatis中，映射文件中的namespace是用于绑定Dao接口的，即面向接口编程。当namespace绑定接口后，可以不用写接口实现类，mybatis会通过该绑定自动帮你找到对应要执行的SQL语句。需要注意的是接口中的方法与映射文件中的SQL语句的id应该一一对应 。 在service包下编写业务层的service接口UserService.java1234567package top.ysccx.ssm.service;import top.ysccx.ssm.entity.User;public interface UserService &#123; User findUserById(int id);&#125; 编写上一步接口的实现类UserServiceImpl.java123456789101112131415161718package top.ysccx.ssm.service;import org.springframework.stereotype.Service;import top.ysccx.ssm.dao.UserDao;import top.ysccx.ssm.entity.User;import javax.annotation.Resource;@Service("userService")public class UserServiceImpl implements UserService &#123; @Resource private UserDao userDao; public User findUserById(int id) &#123; return userDao.findUserById(id); &#125;&#125; 在controller包下编写UserController控制类123456789101112131415161718192021222324package top.ysccx.ssm.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import top.ysccx.ssm.entity.User;import top.ysccx.ssm.service.UserService;import javax.annotation.Resource;@Controller@RequestMapping("")public class UserController &#123; @Resource private UserService userService; @RequestMapping("/findUser") public String findUser(Model model) &#123; int id = 2; User user = this.userService.findUserById(id); model.addAttribute("user", user); return "index"; &#125;&#125; 最后在WEB-INF/views下创建 index.jsp 用于接收并显示数据123456789&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;ssm&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;user.id&#125;:$&#123;user.name&#125;&lt;/body&gt;&lt;/html&gt; 运行结果]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>ssm</tag>
        <tag>整合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三层架构和MVC设计模式]]></title>
    <url>%2F2019%2F03%2F08%2F%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E5%92%8CMVC%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[三层架构：即表现层、业务层、持久层。 持久层：采用DAO模式，建立实体类和数据库表映射（ORM映射）。持久层的目的就是，完成对象数据和关系数据的转换。 业务层：采用事务脚本模式。将一个业务中所有的操作封装成一个方法，同时保证方法中所有的数据库更新操作，即保证同时成功或同时失败。避免部分成功部分失败引起的数据混乱操作。 表现层：采用MVC模式。M称为模型，也就是实体类。用于数据的封装和数据的传输。V为视图，也就是GUI组件，用于数据的展示。C为控制，也就是事件，用于流程的控制。]]></content>
      <categories>
        <category>9-网站架构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MVC</tag>
        <tag>三层架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些惊艳的句子]]></title>
    <url>%2F2019%2F03%2F08%2Fjuzi%2F</url>
    <content type="text"><![CDATA[祝这世界继续热闹，祝我仍然是我 要长大，要可爱，但不要变成各种奇奇怪怪的不可爱的人 一生温暖纯良，不舍爱与自由 只讲今生，不讲来世 我很庆幸，万物众生中磊落做人，怀着诚恳，告诉世界何谓勇敢 不如意事常八九，可与言者无二三 去见你想见的人，去做你想做的事，趁阳光正好，趁微风不噪，趁你未老 识人不必探尽，探尽则多怨。知人不必言尽，言尽则无友。敬人不必卑尽，卑尽则少骨。让人不必退尽，退尽则路艰 突然很喜欢惊鸿一瞥这个词，一见钟情太肤浅，日久生情太苍白，别人眉来眼去，我只偷看你那么一眼 不想成为随处可见的人，这种人随处可见 有时候你会特别渴望找个人谈一谈，但是到最后你会发现，有些事是不能告诉别人的，有些事是不必告诉别人的，有些事是根本没办法用言语告诉别人的，有些事是即使告诉了别人别人也理解不了的，所以你要学着长大，学着慢慢把满腹委屈埋在心里然后做个波澜不惊的人，或许那就是孤独 朝着太阳生长，做一个温暖的人，不卑不亢，清澈善良 要努力做一个可爱的人，不埋怨谁，不嘲笑谁，也不羡慕谁，宁愿跑起来被绊倒无数次，也不要规规矩矩走一辈子，做自己的梦走自己的路爱自己所爱的人 身无饥寒，父母未曾亏我；人无长进，我以何对父母 善良，勇敢，优秀，绝不妥协，祝你也祝我 人生这么辽阔，别光为情所困，用力活一活 我天生不合群。一向话少，时而冷场。有过被孤立，有过被诟病。有过自我质疑，也有过到崩溃的边缘。合也无味，孤也无味。党同伐异，这就是人性。最终决意做个哑巴。少戾气，不言语，从心过活。亚里士多德说“离群索居者，不是野兽，便是神灵。”我既做不上神灵，那当个野兽也好 愿你可以精致到老，眼里长着太阳，笑里全是坦荡 没有谁能左右另一个人的情绪，只有自己不放过自己，谁心里没有故事，只是学会了控制 学会做一个干净洒脱的人，往事不记，后事不提 佛门自清净，我非寡欲人，喝酒，吃肉，动嗔痴，生爱恨 彪悍，勇敢，简单，温暖 愿你有好运，如果没有，希望你在慈悲中学会坚强。愿有很多人爱你，如果没有，希望你在寂寞中学会宽容 惟沉默是最高的轻蔑 目光放远，万事皆悲 无论如何，我一定要去试试，就是不能证明我可以，那也有证明我不可以 可怕的是你庸庸碌碌过一生，还骗自己平淡才是真 其实在人生中，强烈的痛苦和欢愉都是暂时的，最终陪伴你的只会是你内心深处的力量——坚韧和勇敢 所有人都祝你快乐我只愿你，遍历山河，觉得人间值得 记住了，喜欢的东西就不要问别人好看不好看，喜欢胜过所有道理，原则抵不过我乐意31. 我喜欢她，哪怕北京一月打雷三月没黄沙七月飘雪花 我始终觉得，没有哪个人能完完全全了解我，看光我的劣根性，我的阴暗面，我埋在温和表面下的偏激和歇斯底里 祝你所求皆如愿，所行化坦途，多喜乐，长安宁 只谈乾坤风月，莫论人间是非 作者：别浪费我仙气链接：https://www.zhihu.com/question/36539555/answer/575123791来源：知乎]]></content>
      <categories>
        <category>摘录</category>
      </categories>
      <tags>
        <tag>句子</tag>
        <tag>惊艳</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis总结]]></title>
    <url>%2F2019%2F03%2F07%2Fmybatis%2F</url>
    <content type="text"><![CDATA[概述MyBatis是支持定制化SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJO(Plain Old Java Objects,普通Java对象)映射成数据库中的记录。 使用1.将下面的 dependency 代码置于 pom.xml 文件中12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;x.x.x&lt;/version&gt;&lt;/dependency&gt; 2.创建实体类12345678910111213141516171819202122232425262728293031package top.ysccx.mybatis;public class User &#123; private int id; private String name; private String phone; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPhone() &#123; return phone; &#125; public void setPhone(String phone) &#123; this.phone = phone; &#125;&#125; 3.创建核心配置文件mybatis.xml1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;package name="top.ysccx.mybatis"/&gt; &lt;/typeAliases&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="admin"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource="mapper/User.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 4.创建映射配置文件User.xml12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="top.ysccx.mybatis"&gt; &lt;select id="listUser" resultType="User"&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 5.编写测试类123456789101112131415public static void main( String[] args ) &#123; String resource = "mybatis.xml"; Reader reader = null; try&#123; reader = Resources.getResourceAsReader(resource); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); SqlSession session = sqlSessionFactory.openSession(); List&lt;User&gt; cs=session.selectList("listUser"); for (User c : cs) &#123; System.out.println(c.getName()); &#125; &#125; 原理：首先根据配置文件mybatis.xml得到sqlSessionFactory，然后通过sqlSessionFactory得到session，最后通过session的selectList方法，调用sql语句listUser。listUser就是在配置文件User.xml中那条sql语句设置的id。执行完毕之后，得到一个User列表，遍历即可看到数据。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
        <tag>Java</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之树]]></title>
    <url>%2F2019%2F03%2F05%2Ftree%2F</url>
    <content type="text"><![CDATA[二叉树 满二叉树：除叶子结点外的所有结点均有两个子结点。节点数达到最大值，所有叶子结点必须在同一层上。 完全二叉树：叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。 堆堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。 二叉查找树（BST）二叉查找树的特点： 若任意节点的左子树不空，则左子树上所有结点的 值均小于它的根结点的值。 若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值。 任意节点的左、右子树也分别为二叉查找树。 没有键值相等的节点。 平衡二叉树（Self-balancing binary search tree）平衡二叉树具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 红黑树红黑树是一种自平衡二叉查找树。红黑树特点: 每个节点非红即黑； 根节点总是黑色的； 每个叶子节点都是黑色的空节点（NIL节点）； 如果节点是红色的，则它的子节点必须是黑色的（反之不一定）； 从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点。]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十大排序算法总结]]></title>
    <url>%2F2019%2F03%2F05%2Fsort%2F</url>
    <content type="text"><![CDATA[概述排序算法是最经典的算法知识，本文将会总结最常见的十种排序算法。可以用一张图概括： 冒泡排序算法描述 比较相邻的元素。如果第一个比第二个大，就交换它们两个； 针对所有的元素重复以上的步骤，除了最后一个； 重复步骤1~2，直到排序完成。 算法实现123456789101112public static void bubbleSort(int [] arr)&#123; int temp; for(int i = arr.length-1;i&gt;0;i--)&#123; for(int j=0;j&lt;i;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; &#125;&#125; 选择排序算法描述 在未排序序列中找到最小（大）元素，存放到排序序列的起始位置； 从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾； 重复第二步，直到所有元素均排序完毕。 算法实现12345678910111213141516public static void selectionSort(int[] arr)&#123; int temp,min; for(int i=0;i&lt;arr.length-1;i++)&#123; min = i; for(int j=i+1;j&lt;arr.length;j++)&#123; if(arr[min]&gt;arr[j])&#123; min = j; &#125; &#125; if(min!=i)&#123; temp = arr[i]; arr[i] = arr[min]; arr[min] = temp; &#125; &#125;&#125; #插入排序 算法描述 把待排序的数组分成已排序和未排序两部分，初始的时候把第一个元素认为是已排好序的； 从第二个元素开始，在已排好序的子数组中寻找到该元素合适的位置并插入该位置； 重复上述过程直到最后一个元素被插入有序子数组中。 算法实现1234567891011public static void insertSort(int[] arr)&#123; for(int i = 1;i&lt;arr.length;i++)&#123; int temp = arr[i];//记录需要插入的值 int j = i;//记录空出来的位置 while(arr[i]&lt;arr[j-1])&#123; arr[j] = arr[j-1]; j--; &#125; arr[j] = temp; &#125;&#125;]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集和框架]]></title>
    <url>%2F2019%2F03%2F01%2Fjava%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[概述Java集和框架，包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。 Collection1.List ArrayList：基于数组实现，支持随机访问。 Vector：和 ArrayList 类似，但它是线程安全的。 LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。 2.Set HashSet：无序且唯一，基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。 TreeSet：有序且唯一，基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet,HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。 LinkedHashSet：具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。 3.Queue LinkedList：可以用它来实现双向队列。 PriorityQueue：基于堆结构实现，可以用它来实现优先队列。 MapMap的常用方法： TreeMap:基于红黑树实现。 HashMap:基于哈希表实现。 HashTable:和HashMap类似，但它是线程安全的。 LinkedHashMap:使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。]]></content>
      <categories>
        <category>2-容器</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集和</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反射]]></title>
    <url>%2F2019%2F02%2F24%2F%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[反射基础反射 (Reflection) 是 Java 的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。 类对象：所有的类，都存在一个类对象，这个类对象用于提供类本身的信息，比如有几种构造方法， 有多少属性，有哪些方法。 获取类对象的方法有三种：(1) 使用 Class 类的 forName 静态方法:123//注意，forName()需要传入类的全路径//如果当前类与参数类在同一包下即可省略包名Class.forName(driver); (2)直接获取某一个对象的 class，比如:Class class = MyClass.class;(3)调用某个对象的 getClass() 方法，比如:Class class = mClass.getClass(); 通过反射来创建实例通过反射来生成对象主要有两种方式。 使用Class对象的newInstance()方法来创建Class对象对应类的实例。 12Class c = String.class;Object str = c.newInstance(); 先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建实例。这种方法可以用指定的构造器构造类的实例。 1234567//获取String所对应的Class对象Class c = String.class;//获取String类带一个String参数的构造器Constructor constructor = c.getConstructor(String.class);//根据构造器创建实例Object obj = constructor.newInstance(&quot;233&quot;);System.out.println(obj); 通过反射来获取方法获取某个Class对象的方法集合，主要有以下几个方法： getDeclaredMethods 方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。public Method[] getDeclaredMethods() throws SecurityException getMethods 方法返回某个类的所有公用（public）方法，包括其继承类的公用方法。public Method[] getMethods() throws SecurityException getMethod 方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应的Class对象。public Method getMethod(String name, Class class) 通过反射来获取属性 getDeclaredFields 方法返回类或接口所有已声明的成员变量，但不能得到其父类的成员变量。 getFields 方法返回类的所有公有属性，包括其继承的公有方法。 getField 方法返回特定的属性。 通过反射来调用方法用invoke方法1234567Class myClass = MyClass.class;//创建实例Object obj = mClass.newInstance();//获取方法Method method = mClass.getMethod(&quot;add&quot;,int.class,int.class);//调用method对应的方法Object result = method.invoke(obj,1,4); 反射的优点： 可扩展性 ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。 类浏览器和可视化开发环境 ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。 调试器和测试工具 ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。 反射的缺点：尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。 性能开销 ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。 安全限制 ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。 内部暴露 ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。]]></content>
      <categories>
        <category>1-基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础总结]]></title>
    <url>%2F2019%2F02%2F23%2Fjava%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[基本数据类型 byte：Java中最小的数据类型，占1个字节，取值范围-128~127，默认值0 short：短整型，占2个字节，取值范围-32768~32717，默认值0 int：整型，占4个字节，取值范围-2147483648~2147483647，默认值0 long：长整型，占8个字节-2^63~2^63-1，默认值0L float：浮点型，占4个字节，默认值0.0 double：双精度浮点型，占8个字节，默认值0.0 char：字符型，占2个字节，取值范围0~65535，默认值为空 boolean：布尔型，占1个字节，用于判断真或假（仅有两个值，即true、false），默认值false 包装类型基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。12Integer x = 2; // 装箱int y = x; // 拆箱 缓存池new Integer(123) 与 Integer.valueOf(123) 的区别在于： new Integer(123) 每次都会新建一个对象； Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。 String, StringBuffer and StringBuilder 可变性 String 不可变 StringBuffer 和 StringBuilder 可变 线程安全 String 不可变，因此是线程安全的 StringBuilder 不是线程安全的 StringBuffer 是线程安全的，内部使用 synchronized 进行同步 参数传递Java 的参数是以值传递的形式传入方法中，而不是引用传递。 值传递与引用传递的区别在于：值传递的形参不等于实参，而只是实参的一个拷贝。引用传递的形参就等于实参。而不是看它们传递的数据类型是什么。 在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。因此在方法中使形参引用其它对象，那么这两个指针此时指向的是完全不同的对象，在一方改变其所指向对象的内容时对另一方没有影响。 类型转换 数据类型转换要注意以下几点： 低级到高级是自动转换，即隐式类型转换，也叫上转型。 不能对boolean类型进行类型转换。 不能把对象类型转换成不相关类的对象。 在把容量大的类型转换为容量小的类型时必须使用强制类型转换。 转换过程中可能导致溢出或损失精度。 浮点数到整数是通过舍弃小数得到的，而不是四舍五入。 Object通用方法123456789101112131415161718192021public native int hashCode()public boolean equals(Object obj)protected native Object clone() throws CloneNotSupportedExceptionpublic String toString()public final native Class&lt;?&gt; getClass()protected void finalize() throws Throwable &#123;&#125;public final native void notify()public final native void notifyAll()public final native void wait(long timeout) throws InterruptedExceptionpublic final void wait(long timeout, int nanos) throws InterruptedExceptionpublic final void wait() throws InterruptedException final关键字 数据 声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。 对于基本类型，final 使数值不变； 对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。 方法 声明方法不能被子类重写。 private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。 类 声明类不允许被继承。 static关键字 静态变量 静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。 实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。123456789101112public class A &#123; private int x; // 实例变量 private static int y; // 静态变量 public static void main(String[] args) &#123; // int x = A.x; // Non-static field 'x' cannot be referenced from a static context A a = new A(); int x = a.x; int y = A.y; &#125;&#125; 静态方法 静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。 只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。 反射 反射 (Reflection) 是 Java 的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。 详细介绍请点这里 异常 Java中的异常可以是函数中的语句执行时引发的，也可以是程序员通过throw 语句手动抛出的，只要在Java程序中产生了异常，就会用一个对应类型的异常对象来封装异常，JRE就会试图寻找异常处理程序来处理异常。 Java的异常处理有抛出异常和捕获异常。 Throwable类是Java异常类型的顶层父类，一个对象只有是 Throwable 类的（直接或者间接）实例，他才是一个异常对象，才能被异常处理机制识别。JDK中内建了一些常用的异常类，当然也可以自定义异常。 Throwable又派生出Error类和Exception类。 Error类以及他的子类，代表了JVM本身的错误。错误不能通过代码处理，Error很少出现。 Exception类以及他的子类，代表程序运行时发送的各种不期望发生的事件。可以被Java异常处理机制使用，是异常处理的核心。 Java异常又有检查异常和不受检查异常之分。不受检查异常为编译器不要求强制处理的异常，检查异常则是编译器要求必须处置的异常。 检查异常：在正确的程序运行过程中，很容易出现的、情理可容的异常状况，在一定程度上这种异常的发生是可以预测的，并且一旦发生该种异常，就必须采取某种方式进行处理。 不受检查异常：包括RuntimeException及其子类和Error。 Java异常层次结构图如下图所示： 泛型类似c++里的模板函数12345public class Box&lt;T&gt; &#123; private T t; public void set(T t) &#123; this.t = t; &#125; public T get() &#123; return t; &#125;&#125; 获取用键盘输入常用的的两种方法方法1：通过 Scanner123Scanner input = new Scanner(System.in);String s = input.nextLine();input.close(); 方法2：通过 BufferedReader12BufferedReader input = new BufferedReader(new InputStreamReader(System.in)); String s = input.readLine();]]></content>
      <categories>
        <category>1-基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring MVC总结]]></title>
    <url>%2F2019%2F01%2F18%2Fspringmvc%2F</url>
    <content type="text"><![CDATA[概述SpringMVC是一种基于Java，实现了Web MVC设计模式，请求驱动类型的轻量级Web框架，即使用了MVC架构模式的思想，将Web层进行职责解耦。基于请求驱动指的就是使用请求-响应模型，框架的目的就是方便解耦，简化开发，SpringMVC也是要简化我们日常Web开发。SpringMVC框架主要由DispatcherServlet、HandlerMapping、Controller、ViewResolver四个部分组成。 原理图 前端控制器DispatcherServlet前端控制器是整个springmvc的核心，它是一个servlet，负责统一分发请求。 处理器映射HandlerMapping负责完成请求到控制器的映射。在servlet的配置文件中，进行uri与控制器的映射。 控制器Controller负责处理用户请求，完成之后返回ModelAndView对象给前端控制器。 视图解析器ViewResolver负责对ModelAndView对象的解析，并查找对应的View对象。 工作流程 将客户端请求提交给DispatcherServlet 根据&lt;servlet-name&gt;servlet.xml的配置，查找HandlerMapping 通过HandlerMapping找到处理请求的具体Controller Controller调用业务逻辑处理 处理完成之后，返回ModelAndView对象给DispatcherServlet 通过ViewResolver找到负责显示的具体View 由View将结果进行渲染 返回控制权给DispatcherServlet，由DispatcherServlet返回响应给用户，到此一个流程结束。 helloworld1.web.xml1234567891011&lt;web-app&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 如果不指定&lt;param-value&gt;的值，则默认配置文件为/WEB-INF/&lt;servlet-name&gt;-servlet.xml。&lt;load-on-startup&gt;是启动顺序，通常让Servlet跟随Servlet容器一起启动。&lt;url-pattern&gt;定义要拦截的URL请求。 2.springmvc-servlet.xml1234567891011&lt;beans&gt; &lt;bean id=&quot;simpleUrlHandlerMapping&quot; class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt; &lt;property name=&quot;mappings&quot;&gt; &lt;props&gt; &lt;prop key=&quot;/index&quot;&gt;helloWorld&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;helloWorld&quot; class=&quot;top.ysccx.springmvc.HelloWorld&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 表示访问路径/index会交给id=helloworld的bean处理 3.IndexController.java1234567public class HelloWorld implements Controller&#123; public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) &#123; ModelAndView mav = new ModelAndView(&quot;/index.jsp&quot;); mav.addObject(&quot;message&quot;, &quot;hello,world!&quot;); return mav; &#125;&#125; 控制类 IndexController实现接口Controller ，提供方法handleRequest处理请求SpringMVC通过 ModelAndView 对象把模型和视图结合在一起ModelAndView mav = new ModelAndView(“/index.jsp”);mav.addObject(“message”, “hello,world!”);表示视图是index.jsp模型数据是message，内容是 “hello,world!” 4.index.jsp1&lt;h1&gt;$&#123;message&#125;&lt;/h1&gt; index.jsp通过EL表达式显示message的内容 5.运行结果]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>spring</tag>
        <tag>mvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解spring]]></title>
    <url>%2F2019%2F01%2F16%2Fspring%2F</url>
    <content type="text"><![CDATA[概述 Spring是一个轻量级java开发框架。它是为了解决企业应用开发的复杂性而创建的。 Spring就相当于一个大容器，可以将所有对象的创建和依赖关系的维护将给Spring来管理，即控制反转IoC。 Spring的作用就是用于生成bean。 Spring的核心是控制反转（IoC）和面向切面（AOP）。 框架 原理传统的方式：通过new关键字主动创建一个对象。IoC方式：对象的生命周期由Spring来管理，直接从Spring那里获取一个对象。 依赖注入两种方式： 基于xml装配 基于构造方法 基于setter方法 基于注解装配 基于xml装配基于构造方法user.java123456789101112131415161718public class User &#123; private Integer uid; private String username; private Integer age; public User(Integer uid, String username) &#123; super(); this.uid = uid; this.username = username; &#125; public User(String username, Integer age) &#123; super(); this.username = username; this.age = age; &#125;&#125; applicationContext.xml12345678910111213141516171819&lt;!-- 构造方法注入 * &lt;constructor-arg&gt; 用于配置构造方法一个参数argument name ：参数的名称 value：设置普通数据 ref：引用数据，一般是另一个bean id值 index ：参数的索引号，从0开始 。如果只有索引，匹配到了多个构造方法时，默认使用第一个。 type ：确定参数类型 例如：使用名称name &lt;constructor-arg name=&quot;username&quot; value=&quot;jack&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/constructor-arg&gt; 例如2：【类型type 和 索引 index】 &lt;constructor-arg index=&quot;0&quot; type=&quot;java.lang.String&quot; value=&quot;1&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index=&quot;1&quot; type=&quot;java.lang.Integer&quot; value=&quot;2&quot;&gt;&lt;/constructor-arg&gt;--&gt;&lt;bean id=&quot;userId&quot; class=&quot;/.User&quot; &gt; &lt;constructor-arg index=&quot;0&quot; type=&quot;java.lang.String&quot; value=&quot;1&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index=&quot;1&quot; type=&quot;java.lang.Integer&quot; value=&quot;2&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 基于setter方法applicationContext.xml1234567891011121314151617181920212223242526&lt;!-- setter方法注入 * 普通数据 &lt;property name=&quot;&quot; value=&quot;值&quot;&gt; 等效写法 &lt;property name=&quot;&quot;&gt; &lt;value&gt;值&lt;/value&gt; &lt;/property&gt; * 引用数据 &lt;property name=&quot;&quot; ref=&quot;另一个bean&quot;&gt; 等效写法 &lt;property name=&quot;&quot;&gt; &lt;ref bean=&quot;另一个bean&quot;/&gt; &lt;/property&gt;--&gt;&lt;bean id=&quot;personId&quot; class=&quot;Person&quot;&gt; &lt;property name=&quot;pname&quot; value=&quot;chasen&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot;&gt; &lt;value&gt;1234&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;homeAddr&quot; ref=&quot;homeAddrId&quot;&gt;&lt;/property&gt; &lt;property name=&quot;companyAddr&quot;&gt; &lt;ref bean=&quot;companyAddrId&quot;/&gt; &lt;/property&gt;&lt;/bean&gt; 基于注解装配注解，就是一个类。开发中，使用注解取代xml配之文件@Component取代&lt;bean class=&quot;&quot;&gt;@Component(&quot;id&quot;) 取代&lt;bean id=&quot;&quot; class=&quot;&quot;&gt; 面向切面AOP 功能分两大类，辅助功能和核心业务功能 辅助功能和核心业务功能彼此独立进行开发 比如登陆功能，即便是没有性能统计和日志输出，也可以正常运行 如果有需要，就把”日志输出” 功能和 “登陆” 功能 编织在一起，这样登陆的时候，就可以看到日志输出了 辅助功能，又叫做切面，这种能够选择性的，低耦合的把切面和核心业务功能结合在一起的编程思想，就叫做切面编程]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>AOP</tag>
        <tag>Java</tag>
        <tag>spring</tag>
        <tag>IOC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基本规范]]></title>
    <url>%2F2018%2F12%2F16%2Fjavaname%2F</url>
    <content type="text"><![CDATA[命名规范 项目名全部小写 包名全部小写 类名每个单词首字母大写 变量名、方法名从第二个单词开始首字母大写 常量名全部大写 名称只能由字母、数字、下划线、$组成 不能以数字开头 注释规范 单行注释：// 注释内容 多行注释：/… 注释内容…./ 文档注释：/*.. 注释内容…./]]></content>
      <categories>
        <category>1-基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>命名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java swing实现俄罗斯方块]]></title>
    <url>%2F2018%2F11%2F08%2Fels%2F</url>
    <content type="text"><![CDATA[java swing 俄罗斯方块java学习的第一个项目 开始界面 游戏界面 项目地址github地址]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>swing</tag>
        <tag>俄罗斯方块</tag>
        <tag>个人项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解android:layout_weitht]]></title>
    <url>%2F2018%2F11%2F04%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3android-layout-weitht%2F</url>
    <content type="text"><![CDATA[使用前提只有在Linearlayout中，该属性才有效。 先说结论android:layout_weight的真实含义是:一旦View设置了该属性，那么该View的宽度等于原有宽度(android:layout_width)加上剩余空间的weight占比。 举个栗子有如下布局123456789101112131415161718192021&lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; &gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; android:background=&quot;@android:color/black&quot; android:text=&quot;111&quot; android:textSize=&quot;20sp&quot; /&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;2&quot; android:background=&quot;@android:color/holo_green_light&quot; android:text=&quot;222&quot; android:textSize=&quot;20sp&quot; /&gt;&lt;/LinearLayout&gt; 显示效果如下 解释如下设屏幕宽度为L，在两个view的宽度都为match_parent的情况下，原有宽度为L，两个的View的宽度都为L，那么剩余宽度为L-（L+L） = -L, 左边的View占比三分之一，所以总宽度是L+(-L)*1/3 = (2/3)L。]]></content>
      <categories>
        <category>随记</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>layout_weight</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql安装]]></title>
    <url>%2F2018%2F11%2F01%2Fmysql%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[报错如下 net start mysqlMySQL 服务正在启动 .MySQL 服务无法启动。服务没有报告任何错误。请键入 NET HELPMSG 3534 以获得更多的帮助。 解决方案1.以下cmd均需用管理员权限打开 2.mysql\bin目录下，移除已错误安装的mysqld服务 mysqld -remove MySQL 3.mysql\bin目录下执行 mysqld –initialize-insecure 会发现程序在mysql的根目录下自动创建了data文件夹以及相关的文件 4.mysql\bin目录下执行 mysqld -installService successfully installed. 5.启动mysql服务 net start mysqlMySQL 服务正在启动 ..MySQL 服务已经启动成功。]]></content>
      <categories>
        <category>5-数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>error</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[访问修饰符的区别？]]></title>
    <url>%2F2018%2F10%2F30%2Fpublic%2F</url>
    <content type="text"><![CDATA[如图]]></content>
      <categories>
        <category>1-基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>修饰符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两个排序数组找第k大的数]]></title>
    <url>%2F2018%2F10%2F27%2F%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E6%89%BE%E7%AC%ACk%E5%A4%A7%E7%9A%84%E6%95%B0%2F</url>
    <content type="text"><![CDATA[解法一：游标计数定义两个游标分别指向两个有序数组，按序移动，并用count计数，当count等于k时，返回两个游标指向的数中最小的那一个。时间复杂度O(m+n) 实现如下1234567891011121314int findK(int[] nums1, int i, int[] nums2, int j, int k)&#123; int i = 0; int j = 0; int count = 1; while(count&lt;k) &#123; if( nums1[i]&lt;=nums2[j] ) i++; else j++; count++; &#125; return nums1[i]&lt;=nums2[j]?nums1[j]:nums2[i];&#125; 解法二：类二分查找充分利用两个数组都是有序的条件： 当array1[k/2-1] &gt;= array2[k/2-1] 则array2在[0,k/2-1]范围内的元素一定比array1、array2合并后第k个元素小，可以不用考虑array2在[0,k/2-1]范围内的元素 当array1[k/2-1] &lt; array2[k/2-1] 则array1在[0,k/2-1]范围内的元素一定比array1、array2合并后第k个元素小，可以不用考虑array1在[0,k/2-1]范围内的元素 因此算法可以写成一个递归的形式，递归结束的条件为： array1或者array2为空时，return array1[k-1]或者array2[k-1] k==1时，return min(array1[0],array2[0])时间复杂度O(log(m+n))实现如下12345678910111213141516171819202122int findK(int[] nums1, int i, int[] nums2, int j, int k)&#123; int mid1=0, mid2=0; if(i&gt;=nums1.length) return nums2[j+k-1]; if(j&gt;=nums2.length) return nums1[i+k-1]; if(k==1) return Math.min(nums1[i], nums2[j]); if(i+k/2-1&lt;nums1.length)&#123; mid1 = nums1[i+k/2-1]; &#125; else return findK(nums1,i,nums2,j+k/2,k-k/2); if(j+k/2-1&lt;nums2.length)&#123; mid2 = nums2[j+k/2-1]; &#125; else return findK(nums1,i+k/2,nums2,j,k-k/2); if(mid1&lt;mid2)&#123; return findK(nums1,i+k/2,nums2,j,k-k/2); &#125; else&#123; return findK(nums1,i,nums2,j+k/2,k-k/2); &#125;&#125;]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java线程的暂停和恢复]]></title>
    <url>%2F2018%2F10%2F26%2Fjava%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[线程状态 基础前提 Java中的每个对象都有一个监视器，来监测并发代码的重入。 synchronized(obj):对obj加上同步锁并获取该obj的监视器（monitor）。 synchronized(this){}等同于public synchronized void method(){}。 当想要调用wait()进行线程等待时，必须要取得这个锁对象的控制权（监视器），一般是放到synchronized(obj)代码中。 在while循环里而不是if语句下使用wait，这样，会在线程暂停恢复后都检查wait的条件，并在条件实际上并未改变的情况下处理唤醒通知 notify()方法只会通知等待队列中的第一个相关线程（不会通知优先级比较高的线程）。 notifyAll()通知所有等待该竞争资源的线程（也不会按照线程的优先级来执行）。 利用wait()和notify()实现线程的暂停和恢复让目标线程轮询一个自定义锁对象。当需要挂起状态时，线程将使用 Object.wait 进行等待。当线程恢复时，将使用 Object.notify 通知目标线程。实现如下：12345678910111213141516171819Object lock = new Object();boolean isPause = false;public void run()&#123; synchronized (lock)&#123; try &#123; Thread.sleep(600); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; while(isPause)&#123; try &#123; lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; doSomething(); &#125;&#125; 经典生产者消费者问题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/*** 生产者生产出来的产品交给店员*/public synchronized void produce()&#123; if(this.product &gt;= MAX_PRODUCT) &#123; try &#123; wait(); System.out.println(&quot;产品已满,请稍候再生产&quot;); &#125; catch(InterruptedException e) &#123; e.printStackTrace(); &#125; return; &#125; this.product++; System.out.println(&quot;生产者生产第&quot; + this.product + &quot;个产品.&quot;); notifyAll(); //通知等待区的消费者可以取出产品了&#125;/*** 消费者从店员取产品*/public synchronized void consume()&#123; if(this.product &lt;= MIN_PRODUCT) &#123; try &#123; wait(); System.out.println(&quot;缺货,稍候再取&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return; &#125; System.out.println(&quot;消费者取走了第&quot; + this.product + &quot;个产品.&quot;); this.product--; notifyAll(); //通知等待去的生产者可以生产产品了&#125;]]></content>
      <categories>
        <category>3-并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>同步</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求素数个数的几种解法]]></title>
    <url>%2F2018%2F10%2F25%2F%E6%B1%82%E7%B4%A0%E6%95%B0%2F</url>
    <content type="text"><![CDATA[一共三种方法，其中每种方法都能将”j&lt;i”换成”j&lt;i/2”或者”j&lt;sqrt(i)” 方法一利用条件语句if(j==i)判断除数是否到达末尾，若是，则直接count++。1234567for(int i = 2;i&lt;=100;i++) &#123; int j; for (j = 2; j &lt; i; j++) &#123; if (i % j == 0) break; &#125; if(j==i) count++;&#125; 方法二利用isPrime函数判断是否为素数，最后循环计数。1234567891011boolean isPrime(int number)&#123; for (int i = 2; i &lt; number; i++) &#123; if (number % i == 0) &#123; return false; &#125; &#125; return true;&#125;for(int i=2;i&lt;=100;i++)&#123; if(isPrime(i)) count++;&#125; 方法三利用flag标志是否是素数。12345678910111213for(i=2;i&lt;=100;i++)&#123; int flag = 1; int j; for(j=2;j&lt;i;j++)&#123; if(i%j==0)&#123; flag = 0; break; &#125; &#125; if(flag==1)&#123; count++; &#125;&#125;]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>素数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的if __name__ == '__main__' 的作用及原理]]></title>
    <url>%2F2018%2F10%2F23%2Fifname%2F</url>
    <content type="text"><![CDATA[原理由于每个python模块（python文件）都包含内置的变量name，当模块被单独运行的时候，name等于文件名（包含了后缀.py）。如果import到其他模块中，则name等于模块名称（不包含后缀.py）。而“main”等于当前执行文件的名称（包含了后缀.py）。所以当模块被单独运行时，name == ‘main‘结果为真；而当模块被import到其他模块中时，name == ‘main‘结果为假，就是不调用对应的方法。 作用简而言之就是：当模块被单独运行时，该if语句为真，后面的代码将被运行；当模块是被导入时，该if语句为假，后面的代码不被运行。]]></content>
      <categories>
        <category>随记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无重复字符串的最长字串]]></title>
    <url>%2F2018%2F10%2F14%2F%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目给定一个字符串，找出不含有重复字符的最长子串的长度。 思路滑动窗口。 通过使用 HashSet 作为滑动窗口，我们可以用O(1)的时间来完成对字符是否在当前的子字符串中的检查。 滑动窗口是数组/字符串问题中常用的抽象概念。窗口通常是在数组/字符串中由开始和结束索引定义的一系列元素的集合，即 [i, j]。而滑动窗口是可以将两个边界向某一方向“滑动”的窗口。例如，我们将[i, j]向右滑动1个元素，则它将变为 [i+1, j+1]。回到我们的问题，我们使用 HashSet 将字符存储在当前窗口 [i, j]（最初 j = i）中。 然后我们向右侧滑动索引j，如果它不在 HashSet 中，我们会继续滑动j。如果s.charAt(j)已经存在于 HashSet 中，则将索引i向右滑动一格。直到j不小于字符串的length就可以得到答案。 源码12345678910111213141516public int lengthOfLongestSubstring(String s) &#123; HashSet&lt;Character&gt; set = new HashSet&lt;&gt;(); int i = 0, j = 0, max = 0; while(i&lt;s.length()&amp;&amp;j&lt;s.length())&#123; if (!set.contains(s.charAt(j))) &#123; set.add(s.charAt(j)); max = Math.max(max,j-i+1); j++; &#125; else&#123; set.remove(s.charAt(i)); i++; &#125; &#125; return max; &#125;]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈神经网络]]></title>
    <url>%2F2018%2F10%2F14%2F%E6%B5%85%E8%B0%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[神经网络有哪些？现阶段，神经网络大致分为以下几类。 重点介绍一下其中的前馈神经网络神经元神经网络由大量的神经元相互连接而成。每个神经元接受线性组合的输入后，最开始只是简单的线性加权，后来给每个神经元加上了非线性的激活函数，从而进行非线性变换后输出。每两个神经元之间的连接代表加权值，称之为权重（weight）。不同的权重和激活函数，则会导致神经网络不同的输出。神经网络的每个神经元的结构如下：其中 x1,x2表示输入向量 w1,w2为权重，几个输入则意味着有几个权重，即每个输入都被赋予一个权重 b为偏置bias g(z)为激活函数 a为输出 激活函数常用的非线性激活函数有sigmoid、tanh、relu等等，前两者sigmoid/tanh比较常见于全连接层，后者relu常见于卷积层。这里先简要介绍下最基础的sigmoid函数。sigmoid的函数表达式如下sigmoid函数的功能是相当于把一个实数压缩至0到1之间。当z是非常大的正数时，g(z)会趋近于1，而z是非常小的负数时，则g(z)会趋近于0。压缩至0到1有何用处呢？用处是这样一来便可以把激活函数看作一种“分类的概率”，比如激活函数的输出为0.9的话便可以解释为90%的概率为正样本。 神经网络将下图的这种单个神经元组织在一起，便形成了神经网络。下图便是一个三层神经网络结构上图中最左边的原始输入信息称之为输入层，最右边的神经元称之为输出层（上图中输出层只有一个神经元），中间的叫隐藏层。什么输入层、输出层、隐藏层呢？输入层（Input layer），众多神经元（Neuron）接受大量非线形输入讯息。输入的讯息称为输入向量。输出层（Output layer），讯息在神经元链接中传输、分析、权衡，形成输出结果。输出的讯息称为输出向量。隐藏层（Hidden layer），是输入层和输出层之间众多神经元和链接组成的各个层面。如果有多个隐藏层，则意味着多个激活函数。]]></content>
      <categories>
        <category>随记</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>神经网络</tag>
        <tag>激活函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈对hashmap的理解]]></title>
    <url>%2F2018%2F10%2F09%2Fhashmap%2F</url>
    <content type="text"><![CDATA[什么是HashMap？所谓hashmap，即java中的一种数据结构，它存储的是键值对。HashMap 的实例有两个参数影响其性能：“初始容量” 和 “加载因子”。容量 是哈希表中桶的数量，初始容量只是哈希表在创建时的容量。加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构）。 通常，默认加载因子是 0.75, 这是在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操作，都反映了这一点）。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少 rehash 操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。 HashMap的存储实现HashMap 采用一种所谓的“Hash 算法”来决定每个元素的存储位置。 当程序执行map.put(obj1,obj2)时，系统将调用”obj”的 hashCode()方法得到其hashCode值(每个Java对象都有 hashCode()方法都可通过该方法获得它的hashCode值)得到这个对象的hashCode值之后系统会根据该hashCode值来决定该元素的存储位置。 对于 HashMap 及其子类而言，它们采用 Hash 算法来决定集合中元素的存储位置。当系统开始初始化 HashMap 时，系统会创建一个长度为 capacity 的 Entry 数组，这个数组里可以存储元素的位置被称为“桶（bucket）”，每个 bucket 都有其指定索引，系统可以根据其索引快速访问该 bucket 里存储的元素。 无论何时，HashMap 的每个“桶”只存储一个元素（也就是一个 Entry），由于 Entry 对象可以包含一个引用变量（就是 Entry 构造器的的最后一个参数）用于指向下一个 Entry，因此可能出现的情况是：HashMap 的 bucket 中只有一个 Entry，但这个 Entry 指向另一个 Entry ——这就形成了一个 Entry 链。 如果 HashMap 的每个 bucket 里只有一个 Entry 时，HashMap 可以根据索引、快速地取出该 bucket 里的 Entry；在发生“Hash 冲突”的情况下，单个 bucket 里存储的不是一个 Entry，而是一个 Entry 链，系统只能必须按顺序遍历每个 Entry，直到找到想搜索的 Entry 为止——如果恰好要搜索的 Entry 位于该 Entry 链的最末端（该 Entry 是最早放入该 bucket 中），那系统必须循环到最后才能找到该元素。 归纳起来简单地说，HashMap 在底层将 key-value 当成一个整体进行处理，这个整体就是一个 Entry 对象。HashMap 底层采用一个 Entry[] 数组来保存所有的 key-value 对，当需要存储一个 Entry 对象时，会根据 Hash 算法来决定其存储位置；当需要取出一个 Entry 时，也会根据 Hash 算法找到其存储位置，直接取出该 Entry。 当创建 HashMap 时，有一个默认的负载因子（load factor），其默认值为 0.75，这是时间和空间成本上一种折衷：增大负载因子可以减少 Hash 表（就是那个 Entry 数组）所占用的内存空间，但会增加查询数据的时间开销，而查询是最频繁的的操作（HashMap 的 get() 与 put() 方法都要用到查询）；减小负载因子会提高数据查询的性能，但会增加 Hash 表所占用的内存空间。]]></content>
      <categories>
        <category>2-容器</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>hashmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python实现字符画]]></title>
    <url>%2F2018%2F09%2F29%2Fpython%E5%AE%9E%E7%8E%B0%E5%AD%97%E7%AC%A6%E7%94%BB%2F</url>
    <content type="text"><![CDATA[目标将视频转换为字符画并逐帧播放 说明 由于Windows下的命令行实现起来会有闪屏的情况，所以最后改用浏览器+JavaScript的定时器实现播放效果。 chrome内核的浏览器似乎不支持audio标签，所以最好这里使用了ie浏览器。 视频选用了badapple，因为该视频灰度十分明显，实现的效果较好。 本来尝试过在虚拟机下用linux系统的shell来实现播放，无奈的是导入curses库频频报错，最后放弃。 由于制作时间较长，故加入了进度条以引起舒适感。 来张效果图 上代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#导入 opencvimport cv2import numpy as npimport progressbardef video2imgs(video_name, size): img_list = [] # 从指定文件创建一个VideoCapture对象 cap = cv2.VideoCapture(video_name) print(&apos;Please wait a moment...&apos;) # 如果cap对象已经初始化完成了，就返回true，换句话说这是一个 while true 循环 while cap.isOpened(): # cap.read() 返回值介绍： # ret 表示是否读取到图像 # frame 为图像矩阵，类型为 numpy.ndarry. ret, frame = cap.read() if ret: # 转换成灰度图。 gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) # resize 图片，保证图片转换成字符画后，能完整地在命令行中显示。 img = cv2.resize(gray, size, interpolation=cv2.INTER_AREA) # 分帧保存转换结果 img_list.append(img) else: break # 结束时要释放空间 cap.release() return img_list# 用于生成字符画的像素，越往后视觉上越明显。pixels = &quot;$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1&#123;&#125;[]?-_+~&lt;&gt;i!lI;:,\&quot;^`&apos;. &quot;def img2chars(img): res = [] height, width = img.shape for row in range(height): line = &quot;&quot; for col in range(width): # 灰度是用8位表示的，最大值为255。 # 这里将灰度转换到0-1之间 percent = img[row][col] / 255 # 将灰度值进一步转换到 0 到 (len(pixels) - 1) 之间，这样就和 pixels 里的字符对应起来了 index = int(percent * (len(pixels) - 1)) # 添加字符像素（最后面加一个空格，是因为命令行有行距却没几乎有字符间距，用空格当间距） line += pixels[index] + &quot; &quot; with open(&apos;badapple.html&apos;,&apos;a&apos;) as f: f.write(line) f.write(&apos;\n&apos;) def imgs2chars(imgs): for img in progressbar.progressbar(imgs): with open(&apos;badapple.html&apos;,&apos;a&apos;) as f: f.write(&apos;&lt;pre&gt;&apos;) f.write(&apos;\n&apos;) img2chars(img) with open(&apos;badapple.html&apos;,&apos;a&apos;) as f: f.write(&apos;&lt;/pre&gt;&apos;) f.write(&apos;\n&apos;) print(&apos;finish!&apos;)def start(vedio): size = (64, 48) head = &apos;&apos;&apos;&lt;html&gt;&lt;head&gt; &lt;audio autoplay=&quot;autoplay&quot;src=&quot;badapple.mp3&quot;&gt;&lt;/audio&gt;&lt;/head&gt;&lt;style&gt;pre &#123;display:none;font-size:13px;width:923px;height:692px;margin:auto&#125;&lt;/style&gt;&lt;script&gt;window.onload = function()&#123; var pres = document.getElementsByTagName(&apos;pre&apos;); var i = 0; var play = function()&#123; if(i &gt; 0)&#123; pres[i-1].style.display = &apos;none&apos;; &#125; pres[i].style.display = &apos;block&apos;; i++; if(i == pres.length)&#123; clearInterval(run) &#125; &#125; run = setInterval(play, 33.3)&#125;&lt;/script&gt;&lt;body&gt;&apos;&apos;&apos; foot = &apos;&apos;&apos;&lt;/body&gt;&lt;/html&gt;&apos;&apos;&apos; with open(&apos;badapple.html&apos;,&apos;a&apos;) as f: f.write(head) imgs = video2imgs(vedio,size) imgs2chars(imgs) with open(&apos;badapple.html&apos;,&apos;a&apos;) as f: f.write(foot)if __name__ == &quot;__main__&quot;: # *.mp4为视频路径 start(&apos;test.mp4&apos;)]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>字符画</tag>
        <tag>badapple</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Artificial Intelligence]]></title>
    <url>%2F2018%2F09%2F25%2F%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%2F</url>
    <content type="text"><![CDATA[到底何为人工智能？能否用编程实现真正的人工智能？ 答案是：很难。 机器要执行一个连贯的动作的话，是需要人类给它编程的，也就是说，需要人类告诉它，它该怎么做。如果我们不改变它的程序，它将永远这么做下去。也就是说机器只有执行能力，没有学习能力，它不可能自己给自己编写程序。它不可能从一个勤勤恳恳的农民，变成一个手拿兵器冲锋陷阵的士兵。 2016年3月9日，谷歌的智能机器人战胜了韩国的围棋大师李世石，从中可以看出机器人的阴险狡诈和诡计多端。有些人就因此感到害怕了，但是我觉得完全没必要，它的那些能力都是人类赋予给它的，是人类给它编写的程序。如果人类不改变它的程序的话，它将一辈子做一个棋手，永远不可能成为音乐家。有时候，我也觉得人类是一个机器，我们有潜意识和条件反射这些说法。我觉得这些东西就是大脑自己给自己编写好的程序，然后储存起来用的。人的能力不是生来就有的，都是通过后天学习而来的。一种能力就代表一种程序，都是人类自己给自己编写出来的。比如写字，以前我们都不会，都是通过慢慢练习学会的，这个练习的过程就是学习，就是自己在给自己编程。通过学习我们可以掌握很多的技能，这些技能就是我们储存在大脑里的程序。大脑是一个强大的磁盘，它可以储存很多的东西。每一条信息都储存在磁盘的不同位置，大脑也一样，每一个区域储存不同的东西。有些人因为大脑受到创伤，所以会出现一下子失去语言能力的病症，这就是他储存语言能力这个程序的磁盘被破坏了，这条程序没了，所以他突然就不会说话了。因此人工智能最大的障碍就是机器的学习能力，到底要怎样做才能让他们实现自我编程？一旦人工智能实现了自我学习的能力，那他就和人类一样了，所以机器的学习能力才是人类最应该恐惧的能力，学习就意味着变化，就意味着琢磨不透，就意味着潜在的威胁。因此人类最应该遵循的定律就是：千万不能让人工智能拥有自我学习（自我编程）的能力。一旦做到了这一点，无论人工智能多么的强大，我们都不用害怕。一个家政机器人，永远只会给你买菜、做饭、洗衣服，它不可能变成战士去烧杀抢掠；一个工业机器人，永远只会搬运货物，它不可能变成歌手去高声歌唱；一个战争机器人，永远只会杀人，它不可能变成天使去拯救小动物……没有变化就意味着很好掌控，没有学习能力的智能机器人永远都是人类的工具。同理，自己不知道学习，不愿意学习的人，永远都不可能改变自己，永远都只是别人的工具。]]></content>
      <categories>
        <category>随记</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>自我编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于系统引导]]></title>
    <url>%2F2018%2F09%2F18%2F%E5%85%B3%E4%BA%8E%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC%2F</url>
    <content type="text"><![CDATA[事故来源于自己的手贱，用diskgenius删掉了一个esp分区，然后电脑进不了系统了，一直卡在引导界面。 相关知识 esp分区：EFI system partition即efi系统分区。仅当使用uefi模式以及GPT分区表的时候需要EFI系统分区，对于GPT分区表，EFI分区是必需的，它用来存放操作系统的引导器（loader）。 msr分区：Microsoft reserve partition即微软保留分区。GPT格式磁盘用于安装Windows系统都会自动创建该分区。 解决办法 制作winpeU盘。 用diskgenius在任意硬盘新建一个esp分区。 打开uefi引导修复工具，点击挂载，然后开始修复。]]></content>
      <categories>
        <category>随记</category>
      </categories>
      <tags>
        <tag>esp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[步入诗境]]></title>
    <url>%2F2018%2F09%2F05%2Fpoem%2F</url>
    <content type="text"><![CDATA[1 谁，执我之手， 敛我半世癫狂； 谁，吻我之眸， 遮我半世流离。 谁，抚我之面， 慰我半世哀伤； 谁，携我之心， 融我半世冰霜。 谁，扶我之肩， 驱我一世沉寂； 谁，唤我之心， 掩我一生凌轹。 谁，弃我而去， 留我一世独殇； 谁，可明我意， 使我此生无憾。 谁，可助我臂， 纵横万载无双； 谁，可倾我心， 寸土恰似虚弥。 谁，可葬吾怆， 笑天地虚妄，吾心狂。 伊，覆我之唇， 祛我前世流离。 伊，揽我之怀， 除我前世轻浮。 执子之手， 陪你痴狂千生； 深吻子眸， 伴你万世轮回。 执子之手， 共你一世风霜； 吻子之眸， 赠你一世深情。 我，牵尔玉手， 收你此生所有； 我，抚尔秀颈， 挡你此生风雨。 予，挽子青丝， 挽子一世情思； 予，执子之手， 共赴一世情长； 曾，以父之名， 免你一生哀愁； 曾，怜子之情， 祝你一生平安！ 2 那一刻，我升起风马，不为乞福，只为守候你的到来。 那一天，闭目在经殿香雾中，蓦然听见，你颂经中的真言。 那一日，垒起玛尼堆，不为修德，只为投下心湖的石子。 那一夜，我听了一宿梵唱，不为参悟，只为寻你的一丝气息。 那一月，我摇动所有的经筒，不为超度，只为触摸你的指尖。 那一年，磕长头匍匐在山路，不为觐见，只为贴着你的温暖。 那一世，转山转水转佛塔，不为修来生，只为途中与你相见。 那一瞬，我飞升成仙，不为长生，只为佑你平安喜乐。 3 第一最好不相见，如此便可不相恋。 第二最好不相知，如此便可不相思。 第三最好不相伴，如此便可不相欠。 第四最好不相惜，如此便可不相忆。 第五最好不相爱，如此便可不相弃。 第六最好不相对，如此便可不相会。 第七最好不相误，如此便可不相负。 第八最好不相许，如此便可不相续。 第九最好不相依，如此便可不相偎。 第十最好不相遇，如此便可不相聚。 但曾相见便相知，相见何如不见时。 安得与君相诀绝，免教生死作相思。 4 你见，或者不见我， 我就在那里， 不悲不喜。 你念，或者不念我， 情就在那里， 不来不去。 你爱，或者不爱我， 爱就在那里， 不增不减。 你跟，或者不跟我， 我的手就在你手里， 不舍不弃。 来我的怀里， 或者， 让我住进你的心里， 默然相爱， 寂静欢喜。 5 住进布达拉宫， 我是雪域最大的王。 流浪在拉萨街头， 我是世间最美的情郎。 与玛吉阿米的更传神， 自恐多情损梵行， 入山又怕误倾城， 世间安得双全法， 不负如来不负卿。 6 我问佛：为何不给所有女子羞花闭月的容颜？ 佛曰：那只是昙花的一现，用来蒙蔽世俗的眼。 没有什么美可以抵过一颗纯净仁爱的心， 我把它赐给每一个女子， 可有人让它蒙上了灰。 我问佛：世间为何有那么多遗憾？ 佛曰：这是一个婆娑世界，婆娑即遗憾。 没有遗憾，给你再多幸福也不会体会快乐。 我问佛：如何让人们的心不再感到孤单？ 佛曰：每一颗心生来就是孤单而残缺的， 多数带着这种残缺度过一生， 只因与能使它圆满的另一半相遇时， 不是疏忽错过，就是已失去了拥有它的资格。 我问佛：如果遇到了可以爱的人，却又怕不能把握该怎么办？ 佛曰：留人间多少爱，迎浮世千重变， 和有情人，做快乐事， 别问是劫是缘。 我问佛：如何才能如你般睿智？ 佛曰：佛是过来人，人是未来佛。 佛把世间万物分为十界：佛，菩萨，声闻，缘觉，天，阿修罗，人，畜生，饿鬼，地狱。 天，阿修罗，人，畜生，饿鬼，地狱，为六道众生。 六道众生要经历因果轮回，从中体验痛苦。 在体验痛苦的过程中，只有参透生命的真谛，才能得到永生。 凤凰，涅盘。 佛曰：人生有八苦：生，老，病，死，爱别离，怨长久，求不得，放不下。 佛曰：命由己造，相由心生，世间万物皆是化相，心不动，万物皆不动，心不变，万物皆不变。 佛曰：坐亦禅，行亦禅，一花一世界，一叶一如来，春来花自青，秋至叶飘零，无穷般若心自在，语默动静体自然。 佛说：万法皆生，皆系缘份，偶然的相遇，暮然的回首，注定彼此的一生，只为眼光交汇的刹那。 缘起即灭，缘生已空。 我也曾如你般天真。 佛门中说一个人悟道有三阶段：勘破，放下，自在。 的确，一个人必须要放下，才能得到自在。 我问佛：为什么总是在我悲伤的时候下雪？ 佛说：冬天就要过去，留点记忆。 我问佛：为什么每次下雪都是我不在意的夜晚？ 佛说：不经意的时候人们总会错过很多真正的美丽。 我问佛：那过几天还下不下雪？ 佛说：不要只盯着这个季节，错过了今冬。 7 我终于明白， 世间有一种思绪， 无法用言语形容， 粗犷而忧伤。 回声的千结百绕， 而守候的是， 执着。 一如月光下的高原， 一抹淡淡痴痴的笑。 笑那浮华落尽，月色如洗， 笑那悄然而逝，飞花万盏。 谁是那轻轻颤动的百合， 在你的清辉下亘古不变。 谁有那灼灼热烈的双眸， 在你的颔首中攀援而上。 遥远的忧伤， 穿过千山万水。 纵使高原上的风， 吹不散， 执着的背影。 纵使清晨前的霜， 融不化， 心头的温热。 你静守在月下。 悄悄地， 我也开始修心了。]]></content>
      <categories>
        <category>摘录</category>
      </categories>
      <tags>
        <tag>诗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人生苦短]]></title>
    <url>%2F2018%2F08%2F25%2Flife%2F</url>
    <content type="text"><![CDATA[还有什么事想去做？为什么不放弃？为什么不自暴自弃？为什么不一走了之？…… 命运它很吝啬，希望从来都是自己找给自己的。或许你问过了，追求过了，才有答案。 人最艰难的日子，或许连最依赖的人都会远去，或许已经心如死灰万念俱灭，或许连上帝都不会再背负你前行。你永远不知道生命还会给你哪些苦难，你永远不知道自己还会经历多少难熬的岁月。 内心茫然也好，心怀执念也好，痛苦煎熬也好。一步一步，一天一天，一秒一秒，只能靠自己活下去，去感受，去经历，去撑，去熬。一步也少不了，一天也少不了，一秒也少不了。你只能活着，照顾好自己。你只能等，等时间过去。 当路途够长，你已慢慢卸下了绝望，当岁月够久，你已开始看到光亮。再回首，又是一道风景。 你看，世界上还有那么比你更悲惨的人，还在坚强地活着，不是吗？ 人生苦短，你敢不敢笑着走完？ 我敢。 你呢？]]></content>
      <categories>
        <category>摘录</category>
      </categories>
      <tags>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web渗透之隐藏webshell]]></title>
    <url>%2F2018%2F07%2F22%2F%E9%9A%90%E8%97%8Fwebshell%2F</url>
    <content type="text"><![CDATA[大概有以下几种方式 SetHandler可将php代码存于非php后缀文件，例: x.jpg将以下代码写入.htaccess中。 SetHandler application/x-httpd-php 然后连接x.jpg即可启动后门木马。 AddHandler、AddType可将php代码存于非php后缀文件，例: x.logs将以下代码写入.htaccess中AddHandler php5-script .logsAddType text/html .logs连接x.logs，此时x.logs会被apache当成PHP脚本进行解析。 php_value将以下代码写入.htaccess中, 文件路径必须是绝对路径，访问网站上任何php文件都会启动该php后门木马php_value auto_append_file E:/wamp/www/***.php]]></content>
      <categories>
        <category>随记</category>
      </categories>
      <tags>
        <tag>web渗透</tag>
        <tag>php</tag>
        <tag>webshell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爱心]]></title>
    <url>%2F2018%2F05%2F09%2FPython%E7%88%B1%E5%BF%83%2F</url>
    <content type="text"><![CDATA[准备工作首先得知道心形曲线的方程，有以下五种：这里，我就用第一种。其次，要知道函数的伸缩变换法则：那就是逆向法则。函数图像伸长为原来的K倍，则相应的变量乘以1/K。为了打印出来美观，我们可以分别将x和y适当伸长一些。 上代码123456789101112131415161718words = input(&apos;Please input the words you want to say!:&apos;)for item in words.split(): letterlist = [] for y in range(12, -12, -1): list_X = [] letters = &apos;&apos; for x in range(-30, 30):#*是乘法，**是幂次方 expression = ((x*0.05)**2+(y*0.1)**2-1)**3-(x*0.05)**2*(y*0.1)**3 if expression &lt;= 0: letters += item[(x-y) % len(item)] else: letters += &apos; &apos; list_X.append(letters) letterlist += list_X print(&apos;\n&apos;.join(letterlist))#用一行代码可以表示为：#print(&apos;\n&apos;.join([&apos;&apos;.join([(&apos;Love&apos;[(x-y) % len(&apos;Love&apos;)] if ((x*0.05)**2+(y*0.1)**2-1)**3-(x*0.05)**2*(y*0.1)**3 &lt;= 0 else &apos; &apos;) for x in range(-30, 30)]) for y in range(30, -30, -1)]))]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>字符串</tag>
        <tag>爱心</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java环境变量的介绍与配置]]></title>
    <url>%2F2018%2F02%2F11%2F%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[CLASSPATH环境变量它是javac编译器的一个环境变量。它的作用与import、package关键字有关。当你写下improt java.util.*时，编译器面对import关键字时，就知道你要引入java.util这个package中的类；但是编译器如何知道你把这个package放在哪里了呢？所以你首先得告诉编译器这个package的所在位置；如何告诉它呢？就是设置CLASSPATH。 如果java.util这个package在c:/jdk/ 目录下，你得把c:/jdk/这个路径设置到CLASSPATH中去！当编译器面对import java.util.*这个语句时，它先会查找CLASSPATH所指定的目录，并检视子目录java/util是否存在，然后找出名称吻合的已编译文件（.class文件）。如果没有找到就会报错！ PATH环境变量顾名思义，path翻译过来有小路的意思。作用是指定命令搜索路径，在命令行下面执行命令如javac编译java程序时，它会到PATH变量所指定的路径中查找看是否能找到相应的命令程序。我们需要把jdk安装目录下的bin目录增加到现有的PATH变量中，bin目录中包含经常要用到的可执行文件如javac/java/javadoc等待，设置好PATH变量后，就可以在任何目录下执行javac/java等工具了。 JAVA_HOME环境变量它指向jdk的安装目录，Eclipse/NetBeans/Tomcat等软件就是通过搜索JAVA_HOME变量来找到并使用安装好的jdk。 java环境变量配置步骤：在windows桌面上右击“我的电脑” —&gt; “属性” —&gt; “高级” —&gt; “环境变量”，在“系统变量”里我们可以看到系统的各个环境变量的值。双击某个变量名可以修改变量值，变量值之间用“;”隔开。我们还可以“新建”原先没有的变量。与jdk有关的有3个环境变量；“JAVA_HOME”，“PATH”，“CLASSPATH”。CLASSPATH= .;%JAVA_HOME%/lib/dt.jar;%JAVA_HOME%/lib/tools.jarJAVA_HOME = C:/Program Files/Java/jdk1.8.0PATH = %JAVA_HOME%/bin;%JAVA_HOME%/jre/bin 从上面我们可以看出，PATH和CLASSPATH都使用到了JAVA_HOME，也可以使用绝对路径，两者皆可。]]></content>
      <categories>
        <category>随记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>概念</tag>
        <tag>环境变量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[死锁最通俗的解释]]></title>
    <url>%2F2018%2F01%2F05%2Fdeadlock%2F</url>
    <content type="text"><![CDATA[在学习计算机原理的过程中，一直对死锁这一概念理解的不彻底。直到我无意中看到了一位大牛的生动形象的解释。一个生活中的例子：在一条河上有一座桥，桥面较窄，只能容纳一辆汽车通过，无法让两辆汽车并行。如果有两辆汽车A和B分别由桥的两端驶上该桥，则对于A车来说，它走过桥面左面的一段路（即占有了桥的一部分资源），要想过桥还须等待B车让出右边的桥面，此时A车不能前进；对于B车来说，它走过桥面右边的一段路（即占有了桥的一部分资源），要想过桥还须等待A车让出左边的桥面，此时B车也不能前进。两边的车都不倒车，结果造成互相等待对方让出桥面，但是谁也不让路，就会无休止地等下去。这种现象就是死锁。如果把汽车比做进程，桥面作为资源，那么上述问题就描述为：进程A占有资源R1，等待进程B占有的资源Rr；进程B占有资源Rr，等待进程A占有的资源R1。而且资源R1和Rr只允许一个进程占用，即：不允许两个进程同时占用。结果，两个进程都不能继续执行，若不采取其它措施，这种循环等待状况会无限期持续下去，就发生了进程死锁。]]></content>
      <categories>
        <category>3-并发</category>
      </categories>
      <tags>
        <tag>死锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机都解不出来的数学题]]></title>
    <url>%2F2017%2F12%2F04%2F%E5%8F%B2%E4%B8%8A%E6%9C%80%E8%B4%B1%E7%9A%84%E6%95%B0%E5%AD%A6%E9%A2%98%2F</url>
    <content type="text"><![CDATA[这是一道史无前例的数学题，最强大的计算机也解不出来。 这年头，写个电脑程序解决这种形式简单的方程真是太容易了，只要它真的有答案，那电脑最终一定会找出来。但很抱歉，大错特错。用电脑暴力计算在这里毫无用处。首先，提取图片中的数学方程，那么我们要求解的便是这个方程的整数解了。证明：略。（没错，因为太复杂，所以省略。） 最后可以得出答案为：a=154476802108746166441951315019919837485664325669565431700026634898253202035277999b=36875131794129999827197811565225474825492979968971970996283137471637224634055579c=4373612677928697257861252602371390152816537558161613618621437993378423467772036 这些是80位数！你不可能通过暴力计算找到一个80位数（注：简单的算术题，三个10^80的数，总共的组合数就是10^240，神威太湖之光的峰值计算能力为12.5亿亿次每秒，折算不过10^18 次/s，至少需要10^222秒，大约10^214年，更震撼的写法就是1亿亿亿亿亿亿亿亿亿亿亿亿亿亿亿亿亿亿亿亿亿亿亿亿亿亿年）！但无论它看上去怎么不可思议，但这些数值代回原方程，的确等于4：]]></content>
      <categories>
        <category>随记</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>挑战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java解数独的算法实现]]></title>
    <url>%2F2017%2F10%2F03%2Fsudoku%2F</url>
    <content type="text"><![CDATA[算法原理采用深度优先遍历所有可能的值，列出能使数独矩阵成立的组合（俗称暴力破解^_^）。递归深度约为9x9层，每层有1~9这几个可能值。故时间复杂度约为9的81次方！ 待解数独 测试结果 主要代码 Sudo.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class Sudo &#123; int sudoku[][]=new int[9][9]; int flag[][]=new int[9][9]; int row[][]=new int[9][10]; int col[][]=new int[9][10]; int gong[][]=new int[9][10]; int num=0; public void setSudoku(int[][] sudoku) &#123; this.sudoku = sudoku; &#125; public void showSudoku() &#123; for(int i=0;i&lt;9;i++)&#123; for(int j=0;j&lt;9;j++) &#123; System.out.print(sudoku[i][j]); System.out.print(' '); &#125; System.out.println(); &#125; &#125; public void setRow(int i,int j,int tag) &#123; this.row[i][this.sudoku[i][j]]=tag; &#125; public void setCol(int i,int j,int tag)&#123; this.col[j][this.sudoku[i][j]]=tag; &#125; public void setGong(int i,int j,int tag) &#123; this.gong[3*(i/3)+j/3][this.sudoku[i][j]]=tag; &#125; public void initRule()&#123; for(int i=0;i&lt;9;i++)&#123; for(int j=0;j&lt;9;j++)&#123; setRow(i,j,1); setCol(i,j,1); setGong(i,j,1); &#125; &#125; &#125; public void initFlag()&#123; for(int i=0;i&lt;9;i++)&#123; for(int j=0;j&lt;9;j++)&#123; if(sudoku[i][j]==0) flag[i][j]=0; else flag[i][j]=1; &#125; &#125; &#125; public int findNext(int i,int j,int start)&#123; for(int x=start;x&lt;10;x++)&#123; if(row[i][x]==0&amp;&amp;col[j][x]==0&amp;&amp;gong[3*(i/3)+j/3][x]==0) return x; &#125; return -1; &#125; public void solve(int i,int j)&#123; if(j==9)&#123;i++;j=0;&#125; if(i&gt;8)&#123; showSudoku(); System.out.println(); num++; return; &#125; if(flag[i][j]==0) &#123; while(findNext(i,j,sudoku[i][j]+1)!=-1) &#123; //System.out.print(i); //System.out.print(j); //System.out.print(findNext(i,j,sudoku[i][j]+1)); //System.out.println("test"); sudoku[i][j] = findNext(i,j,sudoku[i][j]+1); setRow(i,j,1); setCol(i,j,1); setGong(i,j,1); solve(i,j+1); setRow(i,j,0); setCol(i,j,0); setGong(i,j,0); &#125; sudoku[i][j]=0; &#125; else&#123; solve(i,j+1); &#125; &#125;&#125; Main.java 12345678910111213141516171819202122public class Main &#123; public static void main(String[] args) &#123; Sudo sudo=new Sudo(); int test[][]=&#123; &#123;8,0,0,0,0,0,0,0,0&#125;, &#123;0,0,3,6,0,0,0,0,0&#125;, &#123;0,7,0,0,9,0,2,0,0&#125;, &#123;0,5,0,0,0,7,0,0,0&#125;, &#123;0,0,0,0,4,5,7,0,0&#125;, &#123;0,0,0,1,0,0,0,3,0&#125;, &#123;0,0,1,0,0,0,0,6,8&#125;, &#123;0,0,8,5,0,0,0,1,0&#125;, &#123;0,9,0,0,0,0,4,0,0&#125;, &#125;; int test0[][]=new int[9][9]; sudo.setSudoku(test); sudo.initRule(); sudo.initFlag(); sudo.solve(0,0); &#125;&#125;]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数独</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20岁无资本无未来]]></title>
    <url>%2F2017%2F08%2F25%2F20%E5%B2%81%2F</url>
    <content type="text"><![CDATA[你学习一般，考上了现在的这所学校，成绩不算好，拿不到奖学金，上课不听讲，上自习不规律，考试靠突击，同学帮一把的话也能每科考到七八十分，但是与优秀总有很大距离。你家境一般，父母都是普通员工，你在这个城市的生活费是每月一千二，没事下下馆子，一个月添件衣服，想买台相机，咬咬牙才能买双自己喜欢的鞋。你几乎没有特长，不会弹吉他，不会弹钢琴，不会跳舞，不会画画，想学摄影却不会使用图片处理软件，想上台演出却没信心，学校晚会比赛的时候，你经常是站在台下围观的人群里的一员，你与聚光灯环绕的舞台几乎绝缘。你长相一般，不算英俊或者不算美丽，身材不算臃肿但也没什么肌肉或者没什么曲线，平时只是稍稍打扮一下，看上去并不出众，只能算整洁，与人擦肩而过是对方不会多留意你一眼。你的感情也是一般，有时候会遇见自己心仪的那个人，但是总抓不住机会，眨眼间那个人就被其他人俘获，你就开始伤心、抱怨，但是几天之后又开始寻找新的心上人，就这样看着一个个心上人走过，直到你毕业，与其中任何一个都没有发展。总之，你没有什么特别的地方 ，就和周围的千万个普通人一样。 你不甘心拿不到奖学金，看见别人得奖学金的时候你会说那完全是突击的结果，于是你开始上自习，不过你只坚持了一星期。你不甘心自己的父辈平平，于是你批评讽刺自己周围的“官二代”、“富二代”，立志要努力学习争取成功，也好让自己的孩子成为“富二代”，你的热情持续了一个星期。你不甘心自己什么特长都没有，于是你开始学弹吉他、买滑轮鞋、借来摄影方面的书籍，你对着镜子微笑着说：“你是最棒的。” 这份虚假的信心维持了一个星期。你不甘心自己没有伴侣，你决心洗心革面重新做人，你删掉电脑里的偶像剧肥皂剧，你收拾起床上的懒人桌，把零食袋子统统扔掉，然后洗了个澡并且修饰了一下自己，你往发型上喷了啫喱水，好让自己看起来很精神，你怀揣着一本成功学的书决定出去走走，开始新的生活。这样的状态，你稀稀拉拉地坚持了一个星期。 一个星期之后，你还是和周围千万个人一样，你还是和一星期前的自己一样。你逛网络论坛，看到了这样一句话：“二十岁是人生最美好的时光，不应该局限在学校里教室里，应该享受生活。” 于是你相信了，你觉得二十岁的你就应该“随心所欲”，享受“人生中最后的自由时光”；就应该“快乐地去恋爱”“风华正茂”“挥斥方遒”······现在的你，用着父母的血汗钱，用着名牌包、穿着名牌跑鞋、骑着捷安特山地车、用着佳能牌的相机和苹果牌的手机，还经常去星巴克喝喝咖啡体验一下小资情调······那么，请允许我猜测一下你的未来—— 在大四将要结束时，你考研落榜。你风风火火的参加校园招聘会，很多公司你都看不上，嫌他们不是体制内单位、平台窄、规模小，直到毕业，你还没有找到心仪的工作。你收拾好行李回到老家，父母让你试着参加各种招聘考试或者参加当地的应聘会，你不去，因为你觉得那些工作太简单了，不适合你，你应该去寻找更好的就业机会。可是，当你去那些你看得上的公司应聘时，你的竞争对手太多了，而且都不差，你表现平平，理所当然地被拒之门外······现在的你，也许还在上大学，也许和恋人恩恩爱爱，每天黏在一起，午饭晚饭一起去吃，晚自习后还会一起在操场散步。你们讨论起未来，最后的结论总是：不要想得太多，认真过好现在就好。不幸运的话，几个月后，你们就分手了，你凄凄惨惨戚戚，反复问自己究竟哪里做错了；幸运的话，你们会一直恋爱到毕业，最终，你绝得自己不够优秀没能力去对方所在的城市读研或者工作，所以你们带着不舍和悔恨分手了。现实很残酷，至此，你信了。现在的你喜欢刷微博，你会全力支持那些你赞同的观点，你会激励否定那些你反对的观点。你爱憎分明，看起来很有正义感。你觉得血气方刚的年轻人就应该敢于说出自己的心声。你可能从来不会去想一个问题：你的观点，来自哪里？其实，它们绝大部分来自网络，它们已经蚕食了你的判断力。现在，我只想问你一个问题：二十岁的你，有什么资本。你只是千千万万人中微不足道的一个人，少了你，地球还是一样会转。我敢打赌，一定很久没人和你说过“吃得苦中苦，方为人上人”这句话了吧？你知道“责任”两个字是怎么写的吗? 当你谈论飞翔的时候，你是不是忘记了地心引力的存在？现在的你，如果还是放纵着自己的懒惰与幼稚，虚度着光阴，那么，你就虚度去吧。反正我已经过了二十岁的年纪，我还有未来，我得直奔向前了，不陪你了。再见。]]></content>
      <categories>
        <category>摘录</category>
      </categories>
      <tags>
        <tag>20岁</tag>
        <tag>未来</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git使用总结]]></title>
    <url>%2F2017%2F07%2F30%2Fgit%2F</url>
    <content type="text"><![CDATA[什么是git？分布式版本控制系统。git几乎是所有程序员必备的技能之一，而git教程在网上更是琳琅满目。 git版本库图解 一些基本的git命令 git init git add git commit git remote add origin 仓库地址 git push -u origin master git push git pull git checkout git reset 下面列举一些极好的git学习网站： Git教程 - 廖雪峰的官方网站 Git 教程 | 菜鸟教程]]></content>
      <categories>
        <category>7-工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码起手]]></title>
    <url>%2F2017%2F05%2F17%2F%E4%BB%A3%E7%A0%81%E8%B5%B7%E6%89%8B%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[如来佛祖，永无bug。 12345678910111213141516171819202122232425262728293031/** * _ooOoo_ * o8888888o * 88&quot; . &quot;88 * (| -_- |) * O\ = /O * ____/`---&apos;\____ * .&apos; \\| |// `. * / \\||| : |||// \ * / _||||| -:- |||||- \ * | | \\\ - /// | | * | \_| &apos;&apos;\---/&apos;&apos; | | * \ .-\__ `-` ___/-. / * ___`. .&apos; /--.--\ `. . __ * .&quot;&quot; &apos;&lt; `.___\_&lt;|&gt;_/___.&apos; &gt;&apos;&quot;&quot;. * | | : `- \`.;`\ _ /`;.`/ - ` : | | * \ \ `-. \_ __\ /__ _/ .-` / / * ======`-.____`-.___\_____/___.-`____.-&apos;====== * `=---=&apos; * ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ * 佛祖保佑 永无BUG * 佛曰: * 写字楼里写字间，写字间里程序员； * 程序人员写程序，又拿程序换酒钱。 * 酒醒只在网上坐，酒醉还来网下眠； * 酒醉酒醒日复日，网上网下年复年。 * 但愿老死电脑间，不愿鞠躬老板前； * 奔驰宝马贵者趣，公交自行程序员。 * 别人笑我忒疯癫，我笑自己命太贱； * 不见满街漂亮妹，哪个归得程序员？*/]]></content>
      <categories>
        <category>摘录</category>
      </categories>
      <tags>
        <tag>起手式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2016%2F07%2F25%2Fhello-world%2F</url>
    <content type="text"><![CDATA[一如既往的起手式Hello World!]]></content>
      <categories>
        <category>随记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
